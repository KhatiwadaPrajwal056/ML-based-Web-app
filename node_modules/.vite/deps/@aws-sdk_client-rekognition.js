import {
  Client,
  Command,
  DEFAULT_MAX_ATTEMPTS,
  DEFAULT_RETRY_MODE,
  DEFAULT_USE_DUALSTACK_ENDPOINT,
  DEFAULT_USE_FIPS_ENDPOINT,
  FetchHttpHandler,
  HttpRequest,
  LazyJsonString,
  NoOpLogger,
  SENSITIVE_STRING,
  SMITHY_CONTEXT_KEY,
  ServiceException,
  _json,
  calculateBodyLength,
  collectBody,
  createAggregatedClient,
  decorateServiceException,
  defaultUserAgent,
  expectBoolean,
  expectInt32,
  expectLong,
  expectNonNull,
  expectNumber,
  expectString,
  fromBase64,
  fromUtf8,
  getAwsAuthPlugin,
  getAwsRegionExtensionConfiguration,
  getContentLengthPlugin,
  getDefaultExtensionConfiguration,
  getEndpointPlugin,
  getHostHeaderPlugin,
  getHttpHandlerExtensionConfiguration,
  getLoggerPlugin,
  getRecursionDetectionPlugin,
  getRetryPlugin,
  getSerdePlugin,
  getUserAgentPlugin,
  invalidProvider,
  limitedParseFloat32,
  loadConfigsForDefaultMode,
  parseEpochTimestamp,
  parseUrl,
  require_build,
  resolveAwsAuthConfig,
  resolveAwsRegionExtensionConfiguration,
  resolveDefaultRuntimeConfig,
  resolveDefaultsModeConfig,
  resolveEndpoint,
  resolveEndpointConfig,
  resolveHostHeaderConfig,
  resolveHttpHandlerRuntimeConfig,
  resolveRegionConfig,
  resolveRetryConfig,
  resolveUserAgentConfig,
  serializeFloat,
  streamCollector,
  take,
  toBase64,
  toUtf8,
  withBaseException
} from "./chunk-YZZRZAH4.js";
import {
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@aws-sdk/client-rekognition/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  var _a, _b;
  return {
    ...options,
    useDualstackEndpoint: (_a = options.useDualstackEndpoint) != null ? _a : false,
    useFipsEndpoint: (_b = options.useFipsEndpoint) != null ? _b : false,
    defaultSigningName: "rekognition"
  };
};

// node_modules/@aws-sdk/client-rekognition/package.json
var package_default = {
  name: "@aws-sdk/client-rekognition",
  description: "AWS SDK for JavaScript Rekognition Client for Node.js, Browser and React Native",
  version: "3.449.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo rekognition"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.449.0",
    "@aws-sdk/core": "3.445.0",
    "@aws-sdk/credential-provider-node": "3.449.0",
    "@aws-sdk/middleware-host-header": "3.449.0",
    "@aws-sdk/middleware-logger": "3.449.0",
    "@aws-sdk/middleware-recursion-detection": "3.449.0",
    "@aws-sdk/middleware-signing": "3.449.0",
    "@aws-sdk/middleware-user-agent": "3.449.0",
    "@aws-sdk/region-config-resolver": "3.433.0",
    "@aws-sdk/types": "3.449.0",
    "@aws-sdk/util-endpoints": "3.449.0",
    "@aws-sdk/util-user-agent-browser": "3.449.0",
    "@aws-sdk/util-user-agent-node": "3.449.0",
    "@smithy/config-resolver": "^2.0.16",
    "@smithy/fetch-http-handler": "^2.2.4",
    "@smithy/hash-node": "^2.0.12",
    "@smithy/invalid-dependency": "^2.0.12",
    "@smithy/middleware-content-length": "^2.0.14",
    "@smithy/middleware-endpoint": "^2.1.3",
    "@smithy/middleware-retry": "^2.0.18",
    "@smithy/middleware-serde": "^2.0.12",
    "@smithy/middleware-stack": "^2.0.6",
    "@smithy/node-config-provider": "^2.1.3",
    "@smithy/node-http-handler": "^2.1.8",
    "@smithy/protocol-http": "^3.0.8",
    "@smithy/smithy-client": "^2.1.12",
    "@smithy/types": "^2.4.0",
    "@smithy/url-parser": "^2.0.12",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.1.0",
    "@smithy/util-defaults-mode-browser": "^2.0.16",
    "@smithy/util-defaults-mode-node": "^2.0.21",
    "@smithy/util-endpoints": "^1.0.2",
    "@smithy/util-retry": "^2.0.5",
    "@smithy/util-utf8": "^2.0.0",
    "@smithy/util-waiter": "^2.0.12",
    tslib: "^2.5.0",
    uuid: "^8.3.2"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    "@types/uuid": "^8.3.0",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-rekognition",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-rekognition"
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/runtimeConfig.browser.js
var import_sha256_browser = __toESM(require_build());

// node_modules/@aws-sdk/client-rekognition/dist-es/endpoint/ruleset.js
var s = "required";
var t = "fn";
var u = "argv";
var v = "ref";
var a = true;
var b = "isSet";
var c = "booleanEquals";
var d = "error";
var e = "endpoint";
var f = "tree";
var g = "PartitionResult";
var h = { [s]: false, "type": "String" };
var i = { [s]: true, "default": false, "type": "Boolean" };
var j = { [v]: "Endpoint" };
var k = { [t]: c, [u]: [{ [v]: "UseFIPS" }, true] };
var l = { [t]: c, [u]: [{ [v]: "UseDualStack" }, true] };
var m = {};
var n = { [t]: "getAttr", [u]: [{ [v]: g }, "supportsFIPS"] };
var o = { [t]: c, [u]: [true, { [t]: "getAttr", [u]: [{ [v]: g }, "supportsDualStack"] }] };
var p = [k];
var q = [l];
var r = [{ [v]: "Region" }];
var _data = { version: "1.0", parameters: { Region: h, UseDualStack: i, UseFIPS: i, Endpoint: h }, rules: [{ conditions: [{ [t]: b, [u]: [j] }], rules: [{ conditions: p, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: j, properties: m, headers: m }, type: e }], type: f }, { conditions: [{ [t]: b, [u]: r }], rules: [{ conditions: [{ [t]: "aws.partition", [u]: r, assign: g }], rules: [{ conditions: [k, l], rules: [{ conditions: [{ [t]: c, [u]: [a, n] }, o], rules: [{ endpoint: { url: "https://rekognition-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: p, rules: [{ conditions: [{ [t]: c, [u]: [n, a] }], rules: [{ endpoint: { url: "https://rekognition-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: q, rules: [{ conditions: [o], rules: [{ endpoint: { url: "https://rekognition.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://rekognition.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
var ruleSet = _data;

// node_modules/@aws-sdk/client-rekognition/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  });
};

// node_modules/@aws-sdk/client-rekognition/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return {
    apiVersion: "2016-06-27",
    base64Decoder: (_a = config == null ? void 0 : config.base64Decoder) != null ? _a : fromBase64,
    base64Encoder: (_b = config == null ? void 0 : config.base64Encoder) != null ? _b : toBase64,
    disableHostPrefix: (_c = config == null ? void 0 : config.disableHostPrefix) != null ? _c : false,
    endpointProvider: (_d = config == null ? void 0 : config.endpointProvider) != null ? _d : defaultEndpointResolver,
    extensions: (_e = config == null ? void 0 : config.extensions) != null ? _e : [],
    logger: (_f = config == null ? void 0 : config.logger) != null ? _f : new NoOpLogger(),
    serviceId: (_g = config == null ? void 0 : config.serviceId) != null ? _g : "Rekognition",
    urlParser: (_h = config == null ? void 0 : config.urlParser) != null ? _h : parseUrl,
    utf8Decoder: (_i = config == null ? void 0 : config.utf8Decoder) != null ? _i : fromUtf8,
    utf8Encoder: (_j = config == null ? void 0 : config.utf8Encoder) != null ? _j : toUtf8
  };
};

// node_modules/@aws-sdk/client-rekognition/dist-es/runtimeConfig.browser.js
var getRuntimeConfig2 = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: (_a = config == null ? void 0 : config.bodyLengthChecker) != null ? _a : calculateBodyLength,
    credentialDefaultProvider: (_b = config == null ? void 0 : config.credentialDefaultProvider) != null ? _b : (_) => () => Promise.reject(new Error("Credential is missing")),
    defaultUserAgentProvider: (_c = config == null ? void 0 : config.defaultUserAgentProvider) != null ? _c : defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    maxAttempts: (_d = config == null ? void 0 : config.maxAttempts) != null ? _d : DEFAULT_MAX_ATTEMPTS,
    region: (_e = config == null ? void 0 : config.region) != null ? _e : invalidProvider("Region is missing"),
    requestHandler: (_f = config == null ? void 0 : config.requestHandler) != null ? _f : new FetchHttpHandler(defaultConfigProvider),
    retryMode: (_g = config == null ? void 0 : config.retryMode) != null ? _g : async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE,
    sha256: (_h = config == null ? void 0 : config.sha256) != null ? _h : import_sha256_browser.Sha256,
    streamCollector: (_i = config == null ? void 0 : config.streamCollector) != null ? _i : streamCollector,
    useDualstackEndpoint: (_j = config == null ? void 0 : config.useDualstackEndpoint) != null ? _j : () => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT),
    useFipsEndpoint: (_k = config == null ? void 0 : config.useFipsEndpoint) != null ? _k : () => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT)
  };
};

// node_modules/@aws-sdk/client-rekognition/dist-es/runtimeExtensions.js
var asPartial = (t2) => t2;
var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration)
  };
};

// node_modules/@aws-sdk/client-rekognition/dist-es/RekognitionClient.js
var RekognitionClient = class extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig2(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveUserAgentConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions(_config_7, (configuration == null ? void 0 : configuration.extensions) || []);
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
var i2;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x = input[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b2 = -271733879;
  var c2 = -1732584194;
  var d2 = 271733878;
  for (var i2 = 0; i2 < x.length; i2 += 16) {
    var olda = a2;
    var oldb = b2;
    var oldc = c2;
    var oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x[i2], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x[i2 + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x[i2 + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x[i2 + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x[i2 + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x[i2 + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x[i2 + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x[i2 + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x[i2 + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x[i2 + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x[i2 + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x[i2 + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x[i2 + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x[i2 + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x[i2 + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x[i2], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x[i2 + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x[i2 + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x[i2 + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x[i2 + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x[i2 + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x[i2 + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x[i2 + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x[i2 + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x[i2 + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x[i2 + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x[i2 + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x[i2 + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x[i2 + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x[i2 + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x[i2 + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x[i2 + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x[i2], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x[i2 + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x[i2 + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x[i2 + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x[i2 + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x[i2], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x[i2 + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x[i2 + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x[i2 + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x[i2 + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x[i2 + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x[i2 + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x[i2 + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x[i2 + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x[i2 + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x[i2 + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x[i2 + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a2, b2, x, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x, s2, t2);
}
function md5gg(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x, s2, t2);
}
function md5hh(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x, s2, t2);
}
function md5ii(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x, s2, t2);
}
var md5_default = md5;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/sha1.js
function f2(s2, x, y, z) {
  switch (s2) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N = Math.ceil(l2 / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[_i2][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a2 = H[0];
    var b2 = H[1];
    var c2 = H[2];
    var d2 = H[3];
    var e2 = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s2 = Math.floor(_t2 / 20);
      var T = ROTL(a2, 5) + f2(s2, b2, c2, d2) + e2 + K[s2] + W[_t2] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@aws-sdk/client-rekognition/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/@aws-sdk/client-rekognition/dist-es/models/RekognitionServiceException.js
var RekognitionServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, RekognitionServiceException.prototype);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/models/models_0.js
var AccessDeniedException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccessDeniedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AccessDeniedException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var UnsuccessfulFaceAssociationReason = {
  ASSOCIATED_TO_A_DIFFERENT_USER: "ASSOCIATED_TO_A_DIFFERENT_USER",
  FACE_NOT_FOUND: "FACE_NOT_FOUND",
  LOW_MATCH_CONFIDENCE: "LOW_MATCH_CONFIDENCE"
};
var UserStatus = {
  ACTIVE: "ACTIVE",
  CREATED: "CREATED",
  CREATING: "CREATING",
  UPDATING: "UPDATING"
};
var ConflictException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ConflictException",
      $fault: "client",
      ...opts
    });
    this.name = "ConflictException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ConflictException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var IdempotentParameterMismatchException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "IdempotentParameterMismatchException",
      $fault: "client",
      ...opts
    });
    this.name = "IdempotentParameterMismatchException";
    this.$fault = "client";
    Object.setPrototypeOf(this, IdempotentParameterMismatchException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var InternalServerError = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InternalServerError",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerError";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalServerError.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var InvalidParameterException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InvalidParameterException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidParameterException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidParameterException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ProvisionedThroughputExceededException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ProvisionedThroughputExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "ProvisionedThroughputExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ProvisionedThroughputExceededException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ResourceNotFoundException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ServiceQuotaExceededException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ServiceQuotaExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "ServiceQuotaExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ServiceQuotaExceededException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ThrottlingException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ThrottlingException",
      $fault: "server",
      ...opts
    });
    this.name = "ThrottlingException";
    this.$fault = "server";
    Object.setPrototypeOf(this, ThrottlingException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var Attribute = {
  AGE_RANGE: "AGE_RANGE",
  ALL: "ALL",
  BEARD: "BEARD",
  DEFAULT: "DEFAULT",
  EMOTIONS: "EMOTIONS",
  EYEGLASSES: "EYEGLASSES",
  EYES_OPEN: "EYES_OPEN",
  EYE_DIRECTION: "EYE_DIRECTION",
  FACE_OCCLUDED: "FACE_OCCLUDED",
  GENDER: "GENDER",
  MOUTH_OPEN: "MOUTH_OPEN",
  MUSTACHE: "MUSTACHE",
  SMILE: "SMILE",
  SUNGLASSES: "SUNGLASSES"
};
var BodyPart = {
  FACE: "FACE",
  HEAD: "HEAD",
  LEFT_HAND: "LEFT_HAND",
  RIGHT_HAND: "RIGHT_HAND"
};
var ProtectiveEquipmentType = {
  FACE_COVER: "FACE_COVER",
  HAND_COVER: "HAND_COVER",
  HEAD_COVER: "HEAD_COVER"
};
var EmotionName = {
  ANGRY: "ANGRY",
  CALM: "CALM",
  CONFUSED: "CONFUSED",
  DISGUSTED: "DISGUSTED",
  FEAR: "FEAR",
  HAPPY: "HAPPY",
  SAD: "SAD",
  SURPRISED: "SURPRISED",
  UNKNOWN: "UNKNOWN"
};
var LandmarkType = {
  chinBottom: "chinBottom",
  eyeLeft: "eyeLeft",
  eyeRight: "eyeRight",
  leftEyeBrowLeft: "leftEyeBrowLeft",
  leftEyeBrowRight: "leftEyeBrowRight",
  leftEyeBrowUp: "leftEyeBrowUp",
  leftEyeDown: "leftEyeDown",
  leftEyeLeft: "leftEyeLeft",
  leftEyeRight: "leftEyeRight",
  leftEyeUp: "leftEyeUp",
  leftPupil: "leftPupil",
  midJawlineLeft: "midJawlineLeft",
  midJawlineRight: "midJawlineRight",
  mouthDown: "mouthDown",
  mouthLeft: "mouthLeft",
  mouthRight: "mouthRight",
  mouthUp: "mouthUp",
  nose: "nose",
  noseLeft: "noseLeft",
  noseRight: "noseRight",
  rightEyeBrowLeft: "rightEyeBrowLeft",
  rightEyeBrowRight: "rightEyeBrowRight",
  rightEyeBrowUp: "rightEyeBrowUp",
  rightEyeDown: "rightEyeDown",
  rightEyeLeft: "rightEyeLeft",
  rightEyeRight: "rightEyeRight",
  rightEyeUp: "rightEyeUp",
  rightPupil: "rightPupil",
  upperJawlineLeft: "upperJawlineLeft",
  upperJawlineRight: "upperJawlineRight"
};
var KnownGenderType = {
  Female: "Female",
  Male: "Male",
  Nonbinary: "Nonbinary",
  Unlisted: "Unlisted"
};
var GenderType = {
  Female: "Female",
  Male: "Male"
};
var CelebrityRecognitionSortBy = {
  ID: "ID",
  TIMESTAMP: "TIMESTAMP"
};
var QualityFilter = {
  AUTO: "AUTO",
  HIGH: "HIGH",
  LOW: "LOW",
  MEDIUM: "MEDIUM",
  NONE: "NONE"
};
var OrientationCorrection = {
  ROTATE_0: "ROTATE_0",
  ROTATE_180: "ROTATE_180",
  ROTATE_270: "ROTATE_270",
  ROTATE_90: "ROTATE_90"
};
var ImageTooLargeException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ImageTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "ImageTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ImageTooLargeException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var InvalidImageFormatException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InvalidImageFormatException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidImageFormatException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidImageFormatException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var InvalidS3ObjectException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InvalidS3ObjectException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidS3ObjectException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidS3ObjectException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ContentClassifier = {
  FREE_OF_ADULT_CONTENT: "FreeOfAdultContent",
  FREE_OF_PERSONALLY_IDENTIFIABLE_INFORMATION: "FreeOfPersonallyIdentifiableInformation"
};
var ContentModerationAggregateBy = {
  SEGMENTS: "SEGMENTS",
  TIMESTAMPS: "TIMESTAMPS"
};
var ContentModerationSortBy = {
  NAME: "NAME",
  TIMESTAMP: "TIMESTAMP"
};
var LimitExceededException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "LimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, LimitExceededException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ResourceInUseException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ResourceInUseException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceInUseException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceInUseException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ResourceAlreadyExistsException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ResourceAlreadyExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceAlreadyExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceAlreadyExistsException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var DatasetType = {
  TEST: "TEST",
  TRAIN: "TRAIN"
};
var ProjectAutoUpdate = {
  DISABLED: "DISABLED",
  ENABLED: "ENABLED"
};
var CustomizationFeature = {
  CONTENT_MODERATION: "CONTENT_MODERATION",
  CUSTOM_LABELS: "CUSTOM_LABELS"
};
var DatasetStatus = {
  CREATE_COMPLETE: "CREATE_COMPLETE",
  CREATE_FAILED: "CREATE_FAILED",
  CREATE_IN_PROGRESS: "CREATE_IN_PROGRESS",
  DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS",
  UPDATE_COMPLETE: "UPDATE_COMPLETE",
  UPDATE_FAILED: "UPDATE_FAILED",
  UPDATE_IN_PROGRESS: "UPDATE_IN_PROGRESS"
};
var DatasetStatusMessageCode = {
  CLIENT_ERROR: "CLIENT_ERROR",
  SERVICE_ERROR: "SERVICE_ERROR",
  SUCCESS: "SUCCESS"
};
var UnsuccessfulFaceDeletionReason = {
  ASSOCIATED_TO_AN_EXISTING_USER: "ASSOCIATED_TO_AN_EXISTING_USER",
  FACE_NOT_FOUND: "FACE_NOT_FOUND"
};
var ProjectStatus = {
  CREATED: "CREATED",
  CREATING: "CREATING",
  DELETING: "DELETING"
};
var InvalidPolicyRevisionIdException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InvalidPolicyRevisionIdException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidPolicyRevisionIdException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidPolicyRevisionIdException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var ProjectVersionStatus = {
  COPYING_COMPLETED: "COPYING_COMPLETED",
  COPYING_FAILED: "COPYING_FAILED",
  COPYING_IN_PROGRESS: "COPYING_IN_PROGRESS",
  DELETING: "DELETING",
  DEPRECATED: "DEPRECATED",
  EXPIRED: "EXPIRED",
  FAILED: "FAILED",
  RUNNING: "RUNNING",
  STARTING: "STARTING",
  STOPPED: "STOPPED",
  STOPPING: "STOPPING",
  TRAINING_COMPLETED: "TRAINING_COMPLETED",
  TRAINING_FAILED: "TRAINING_FAILED",
  TRAINING_IN_PROGRESS: "TRAINING_IN_PROGRESS"
};
var InvalidPaginationTokenException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InvalidPaginationTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidPaginationTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidPaginationTokenException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var StreamProcessorStatus = {
  FAILED: "FAILED",
  RUNNING: "RUNNING",
  STARTING: "STARTING",
  STOPPED: "STOPPED",
  STOPPING: "STOPPING",
  UPDATING: "UPDATING"
};
var ResourceNotReadyException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotReadyException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotReadyException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotReadyException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var DetectLabelsFeatureName = {
  GENERAL_LABELS: "GENERAL_LABELS",
  IMAGE_PROPERTIES: "IMAGE_PROPERTIES"
};
var HumanLoopQuotaExceededException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "HumanLoopQuotaExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "HumanLoopQuotaExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, HumanLoopQuotaExceededException.prototype);
    this.ResourceType = opts.ResourceType;
    this.QuotaCode = opts.QuotaCode;
    this.ServiceCode = opts.ServiceCode;
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var TextTypes = {
  LINE: "LINE",
  WORD: "WORD"
};
var UnsuccessfulFaceDisassociationReason = {
  ASSOCIATED_TO_A_DIFFERENT_USER: "ASSOCIATED_TO_A_DIFFERENT_USER",
  FACE_NOT_FOUND: "FACE_NOT_FOUND"
};
var FaceAttributes = {
  ALL: "ALL",
  DEFAULT: "DEFAULT"
};
var FaceSearchSortBy = {
  INDEX: "INDEX",
  TIMESTAMP: "TIMESTAMP"
};
var VideoJobStatus = {
  FAILED: "FAILED",
  IN_PROGRESS: "IN_PROGRESS",
  SUCCEEDED: "SUCCEEDED"
};
var VideoColorRange = {
  FULL: "FULL",
  LIMITED: "LIMITED"
};
var LivenessSessionStatus = {
  CREATED: "CREATED",
  EXPIRED: "EXPIRED",
  FAILED: "FAILED",
  IN_PROGRESS: "IN_PROGRESS",
  SUCCEEDED: "SUCCEEDED"
};
var SessionNotFoundException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "SessionNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "SessionNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, SessionNotFoundException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var LabelDetectionAggregateBy = {
  SEGMENTS: "SEGMENTS",
  TIMESTAMPS: "TIMESTAMPS"
};
var LabelDetectionSortBy = {
  NAME: "NAME",
  TIMESTAMP: "TIMESTAMP"
};
var MediaAnalysisJobFailureCode = {
  ACCESS_DENIED: "ACCESS_DENIED",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_KMS_KEY: "INVALID_KMS_KEY",
  INVALID_MANIFEST: "INVALID_MANIFEST",
  INVALID_OUTPUT_CONFIG: "INVALID_OUTPUT_CONFIG",
  INVALID_S3_OBJECT: "INVALID_S3_OBJECT",
  RESOURCE_NOT_FOUND: "RESOURCE_NOT_FOUND",
  RESOURCE_NOT_READY: "RESOURCE_NOT_READY",
  THROTTLED: "THROTTLED"
};
var MediaAnalysisJobStatus = {
  CREATED: "CREATED",
  FAILED: "FAILED",
  IN_PROGRESS: "IN_PROGRESS",
  QUEUED: "QUEUED",
  SUCCEEDED: "SUCCEEDED"
};
var PersonTrackingSortBy = {
  INDEX: "INDEX",
  TIMESTAMP: "TIMESTAMP"
};
var TechnicalCueType = {
  BLACK_FRAMES: "BlackFrames",
  COLOR_BARS: "ColorBars",
  CONTENT: "Content",
  END_CREDITS: "EndCredits",
  OPENING_CREDITS: "OpeningCredits",
  SLATE: "Slate",
  STUDIO_LOGO: "StudioLogo"
};
var SegmentType = {
  SHOT: "SHOT",
  TECHNICAL_CUE: "TECHNICAL_CUE"
};
var Reason = {
  EXCEEDS_MAX_FACES: "EXCEEDS_MAX_FACES",
  EXTREME_POSE: "EXTREME_POSE",
  LOW_BRIGHTNESS: "LOW_BRIGHTNESS",
  LOW_CONFIDENCE: "LOW_CONFIDENCE",
  LOW_FACE_QUALITY: "LOW_FACE_QUALITY",
  LOW_SHARPNESS: "LOW_SHARPNESS",
  SMALL_BOUNDING_BOX: "SMALL_BOUNDING_BOX"
};
var InvalidManifestException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "InvalidManifestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidManifestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidManifestException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var LabelDetectionFeatureName = {
  GENERAL_LABELS: "GENERAL_LABELS"
};
var MalformedPolicyDocumentException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "MalformedPolicyDocumentException",
      $fault: "client",
      ...opts
    });
    this.name = "MalformedPolicyDocumentException";
    this.$fault = "client";
    Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var AuditImageFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Bytes && { Bytes: SENSITIVE_STRING }
});
var GetFaceLivenessSessionResultsResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.ReferenceImage && { ReferenceImage: AuditImageFilterSensitiveLog(obj.ReferenceImage) },
  ...obj.AuditImages && { AuditImages: obj.AuditImages.map((item) => AuditImageFilterSensitiveLog(item)) }
});

// node_modules/@aws-sdk/client-rekognition/dist-es/models/models_1.js
var UnsearchedFaceReason = {
  EXCEEDS_MAX_FACES: "EXCEEDS_MAX_FACES",
  EXTREME_POSE: "EXTREME_POSE",
  FACE_NOT_LARGEST: "FACE_NOT_LARGEST",
  LOW_BRIGHTNESS: "LOW_BRIGHTNESS",
  LOW_CONFIDENCE: "LOW_CONFIDENCE",
  LOW_FACE_QUALITY: "LOW_FACE_QUALITY",
  LOW_SHARPNESS: "LOW_SHARPNESS",
  SMALL_BOUNDING_BOX: "SMALL_BOUNDING_BOX"
};
var VideoTooLargeException = class extends RekognitionServiceException {
  constructor(opts) {
    super({
      name: "VideoTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "VideoTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, VideoTooLargeException.prototype);
    this.Message = opts.Message;
    this.Code = opts.Code;
    this.Logref = opts.Logref;
  }
};
var StreamProcessorParameterToDelete = {
  ConnectedHomeMinConfidence: "ConnectedHomeMinConfidence",
  RegionsOfInterest: "RegionsOfInterest"
};

// node_modules/@aws-sdk/client-rekognition/dist-es/protocols/Aws_json1_1.js
var se_AssociateFacesCommand = async (input, context) => {
  const headers = sharedHeaders("AssociateFaces");
  let body;
  body = JSON.stringify(se_AssociateFacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CompareFacesCommand = async (input, context) => {
  const headers = sharedHeaders("CompareFaces");
  let body;
  body = JSON.stringify(se_CompareFacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CopyProjectVersionCommand = async (input, context) => {
  const headers = sharedHeaders("CopyProjectVersion");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateCollectionCommand = async (input, context) => {
  const headers = sharedHeaders("CreateCollection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateDatasetCommand = async (input, context) => {
  const headers = sharedHeaders("CreateDataset");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateFaceLivenessSessionCommand = async (input, context) => {
  const headers = sharedHeaders("CreateFaceLivenessSession");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateProjectCommand = async (input, context) => {
  const headers = sharedHeaders("CreateProject");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateProjectVersionCommand = async (input, context) => {
  const headers = sharedHeaders("CreateProjectVersion");
  let body;
  body = JSON.stringify(se_CreateProjectVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateStreamProcessorCommand = async (input, context) => {
  const headers = sharedHeaders("CreateStreamProcessor");
  let body;
  body = JSON.stringify(se_CreateStreamProcessorRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_CreateUserCommand = async (input, context) => {
  const headers = sharedHeaders("CreateUser");
  let body;
  body = JSON.stringify(se_CreateUserRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteCollectionCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteCollection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteDatasetCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteDataset");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteFacesCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteFaces");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteProjectCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteProject");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteProjectPolicyCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteProjectPolicy");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteProjectVersionCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteProjectVersion");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteStreamProcessorCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteStreamProcessor");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteUserCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteUser");
  let body;
  body = JSON.stringify(se_DeleteUserRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeCollectionCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeCollection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeDatasetCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeDataset");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeProjectsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeProjects");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeProjectVersionsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeProjectVersions");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeStreamProcessorCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeStreamProcessor");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DetectCustomLabelsCommand = async (input, context) => {
  const headers = sharedHeaders("DetectCustomLabels");
  let body;
  body = JSON.stringify(se_DetectCustomLabelsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DetectFacesCommand = async (input, context) => {
  const headers = sharedHeaders("DetectFaces");
  let body;
  body = JSON.stringify(se_DetectFacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DetectLabelsCommand = async (input, context) => {
  const headers = sharedHeaders("DetectLabels");
  let body;
  body = JSON.stringify(se_DetectLabelsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DetectModerationLabelsCommand = async (input, context) => {
  const headers = sharedHeaders("DetectModerationLabels");
  let body;
  body = JSON.stringify(se_DetectModerationLabelsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DetectProtectiveEquipmentCommand = async (input, context) => {
  const headers = sharedHeaders("DetectProtectiveEquipment");
  let body;
  body = JSON.stringify(se_DetectProtectiveEquipmentRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DetectTextCommand = async (input, context) => {
  const headers = sharedHeaders("DetectText");
  let body;
  body = JSON.stringify(se_DetectTextRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DisassociateFacesCommand = async (input, context) => {
  const headers = sharedHeaders("DisassociateFaces");
  let body;
  body = JSON.stringify(se_DisassociateFacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DistributeDatasetEntriesCommand = async (input, context) => {
  const headers = sharedHeaders("DistributeDatasetEntries");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetCelebrityInfoCommand = async (input, context) => {
  const headers = sharedHeaders("GetCelebrityInfo");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetCelebrityRecognitionCommand = async (input, context) => {
  const headers = sharedHeaders("GetCelebrityRecognition");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetContentModerationCommand = async (input, context) => {
  const headers = sharedHeaders("GetContentModeration");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetFaceDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("GetFaceDetection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetFaceLivenessSessionResultsCommand = async (input, context) => {
  const headers = sharedHeaders("GetFaceLivenessSessionResults");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetFaceSearchCommand = async (input, context) => {
  const headers = sharedHeaders("GetFaceSearch");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetLabelDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("GetLabelDetection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetMediaAnalysisJobCommand = async (input, context) => {
  const headers = sharedHeaders("GetMediaAnalysisJob");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetPersonTrackingCommand = async (input, context) => {
  const headers = sharedHeaders("GetPersonTracking");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetSegmentDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("GetSegmentDetection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetTextDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("GetTextDetection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_IndexFacesCommand = async (input, context) => {
  const headers = sharedHeaders("IndexFaces");
  let body;
  body = JSON.stringify(se_IndexFacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListCollectionsCommand = async (input, context) => {
  const headers = sharedHeaders("ListCollections");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListDatasetEntriesCommand = async (input, context) => {
  const headers = sharedHeaders("ListDatasetEntries");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListDatasetLabelsCommand = async (input, context) => {
  const headers = sharedHeaders("ListDatasetLabels");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListFacesCommand = async (input, context) => {
  const headers = sharedHeaders("ListFaces");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListMediaAnalysisJobsCommand = async (input, context) => {
  const headers = sharedHeaders("ListMediaAnalysisJobs");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListProjectPoliciesCommand = async (input, context) => {
  const headers = sharedHeaders("ListProjectPolicies");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListStreamProcessorsCommand = async (input, context) => {
  const headers = sharedHeaders("ListStreamProcessors");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListTagsForResourceCommand = async (input, context) => {
  const headers = sharedHeaders("ListTagsForResource");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListUsersCommand = async (input, context) => {
  const headers = sharedHeaders("ListUsers");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutProjectPolicyCommand = async (input, context) => {
  const headers = sharedHeaders("PutProjectPolicy");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_RecognizeCelebritiesCommand = async (input, context) => {
  const headers = sharedHeaders("RecognizeCelebrities");
  let body;
  body = JSON.stringify(se_RecognizeCelebritiesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_SearchFacesCommand = async (input, context) => {
  const headers = sharedHeaders("SearchFaces");
  let body;
  body = JSON.stringify(se_SearchFacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_SearchFacesByImageCommand = async (input, context) => {
  const headers = sharedHeaders("SearchFacesByImage");
  let body;
  body = JSON.stringify(se_SearchFacesByImageRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_SearchUsersCommand = async (input, context) => {
  const headers = sharedHeaders("SearchUsers");
  let body;
  body = JSON.stringify(se_SearchUsersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_SearchUsersByImageCommand = async (input, context) => {
  const headers = sharedHeaders("SearchUsersByImage");
  let body;
  body = JSON.stringify(se_SearchUsersByImageRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartCelebrityRecognitionCommand = async (input, context) => {
  const headers = sharedHeaders("StartCelebrityRecognition");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartContentModerationCommand = async (input, context) => {
  const headers = sharedHeaders("StartContentModeration");
  let body;
  body = JSON.stringify(se_StartContentModerationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartFaceDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("StartFaceDetection");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartFaceSearchCommand = async (input, context) => {
  const headers = sharedHeaders("StartFaceSearch");
  let body;
  body = JSON.stringify(se_StartFaceSearchRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartLabelDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("StartLabelDetection");
  let body;
  body = JSON.stringify(se_StartLabelDetectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartMediaAnalysisJobCommand = async (input, context) => {
  const headers = sharedHeaders("StartMediaAnalysisJob");
  let body;
  body = JSON.stringify(se_StartMediaAnalysisJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartPersonTrackingCommand = async (input, context) => {
  const headers = sharedHeaders("StartPersonTracking");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartProjectVersionCommand = async (input, context) => {
  const headers = sharedHeaders("StartProjectVersion");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartSegmentDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("StartSegmentDetection");
  let body;
  body = JSON.stringify(se_StartSegmentDetectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartStreamProcessorCommand = async (input, context) => {
  const headers = sharedHeaders("StartStreamProcessor");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartTextDetectionCommand = async (input, context) => {
  const headers = sharedHeaders("StartTextDetection");
  let body;
  body = JSON.stringify(se_StartTextDetectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StopProjectVersionCommand = async (input, context) => {
  const headers = sharedHeaders("StopProjectVersion");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StopStreamProcessorCommand = async (input, context) => {
  const headers = sharedHeaders("StopStreamProcessor");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_TagResourceCommand = async (input, context) => {
  const headers = sharedHeaders("TagResource");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_UntagResourceCommand = async (input, context) => {
  const headers = sharedHeaders("UntagResource");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_UpdateDatasetEntriesCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateDatasetEntries");
  let body;
  body = JSON.stringify(se_UpdateDatasetEntriesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_UpdateStreamProcessorCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateStreamProcessor");
  let body;
  body = JSON.stringify(se_UpdateStreamProcessorRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var de_AssociateFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_AssociateFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_AssociateFacesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_AssociateFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConflictException":
    case "com.amazonaws.rekognition#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CompareFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CompareFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_CompareFacesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CompareFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CopyProjectVersionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CopyProjectVersionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CopyProjectVersionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateCollectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateCollectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateCollectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.rekognition#ResourceAlreadyExistsException":
      throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateDatasetCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateDatasetCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateDatasetCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.rekognition#ResourceAlreadyExistsException":
      throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateFaceLivenessSessionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateFaceLivenessSessionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateFaceLivenessSessionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateProjectCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateProjectCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateProjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateProjectVersionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateProjectVersionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateProjectVersionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateStreamProcessorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateStreamProcessorCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateStreamProcessorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_CreateUserCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CreateUserCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CreateUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConflictException":
    case "com.amazonaws.rekognition#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteCollectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteCollectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteCollectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteDatasetCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteDatasetCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteDatasetCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteProjectCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteProjectCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteProjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteProjectPolicyCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteProjectPolicyCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteProjectPolicyCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidPolicyRevisionIdException":
    case "com.amazonaws.rekognition#InvalidPolicyRevisionIdException":
      throw await de_InvalidPolicyRevisionIdExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteProjectVersionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteProjectVersionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteProjectVersionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteStreamProcessorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteStreamProcessorCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteStreamProcessorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteUserCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteUserCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConflictException":
    case "com.amazonaws.rekognition#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DescribeCollectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DescribeCollectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DescribeCollectionResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeCollectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DescribeDatasetCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DescribeDatasetCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DescribeDatasetResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeDatasetCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DescribeProjectsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DescribeProjectsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DescribeProjectsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeProjectsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DescribeProjectVersionsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DescribeProjectVersionsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DescribeProjectVersionsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeProjectVersionsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DescribeStreamProcessorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DescribeStreamProcessorCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DescribeStreamProcessorResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeStreamProcessorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DetectCustomLabelsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DetectCustomLabelsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DetectCustomLabelsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DetectCustomLabelsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.rekognition#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DetectFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DetectFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DetectFacesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DetectFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DetectLabelsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DetectLabelsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DetectLabelsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DetectLabelsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DetectModerationLabelsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DetectModerationLabelsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DetectModerationLabelsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DetectModerationLabelsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "HumanLoopQuotaExceededException":
    case "com.amazonaws.rekognition#HumanLoopQuotaExceededException":
      throw await de_HumanLoopQuotaExceededExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.rekognition#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DetectProtectiveEquipmentCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DetectProtectiveEquipmentCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DetectProtectiveEquipmentResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DetectProtectiveEquipmentCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DetectTextCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DetectTextCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_DetectTextResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DetectTextCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DisassociateFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DisassociateFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DisassociateFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConflictException":
    case "com.amazonaws.rekognition#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DistributeDatasetEntriesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DistributeDatasetEntriesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DistributeDatasetEntriesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.rekognition#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetCelebrityInfoCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetCelebrityInfoCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetCelebrityInfoCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetCelebrityRecognitionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetCelebrityRecognitionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetCelebrityRecognitionResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetCelebrityRecognitionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetContentModerationCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetContentModerationCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetContentModerationResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetContentModerationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetFaceDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetFaceDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetFaceDetectionResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetFaceDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetFaceLivenessSessionResultsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetFaceLivenessSessionResultsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetFaceLivenessSessionResultsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetFaceLivenessSessionResultsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "SessionNotFoundException":
    case "com.amazonaws.rekognition#SessionNotFoundException":
      throw await de_SessionNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetFaceSearchCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetFaceSearchCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetFaceSearchResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetFaceSearchCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetLabelDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetLabelDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetLabelDetectionResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetLabelDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetMediaAnalysisJobCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetMediaAnalysisJobCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetMediaAnalysisJobResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetMediaAnalysisJobCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetPersonTrackingCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetPersonTrackingCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetPersonTrackingResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetPersonTrackingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetSegmentDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetSegmentDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetSegmentDetectionResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetSegmentDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_GetTextDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_GetTextDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_GetTextDetectionResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetTextDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_IndexFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_IndexFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_IndexFacesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_IndexFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListCollectionsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListCollectionsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListCollectionsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListDatasetEntriesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListDatasetEntriesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListDatasetEntriesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.rekognition#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListDatasetLabelsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListDatasetLabelsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListDatasetLabelsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.rekognition#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_ListFacesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListMediaAnalysisJobsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListMediaAnalysisJobsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_ListMediaAnalysisJobsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListMediaAnalysisJobsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListProjectPoliciesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListProjectPoliciesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_ListProjectPoliciesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListProjectPoliciesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListStreamProcessorsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListStreamProcessorsCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListStreamProcessorsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListTagsForResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListTagsForResourceCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListTagsForResourceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ListUsersCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_ListUsersCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListUsersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidPaginationTokenException":
    case "com.amazonaws.rekognition#InvalidPaginationTokenException":
      throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_PutProjectPolicyCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_PutProjectPolicyCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_PutProjectPolicyCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidPolicyRevisionIdException":
    case "com.amazonaws.rekognition#InvalidPolicyRevisionIdException":
      throw await de_InvalidPolicyRevisionIdExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "MalformedPolicyDocumentException":
    case "com.amazonaws.rekognition#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.rekognition#ResourceAlreadyExistsException":
      throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_RecognizeCelebritiesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_RecognizeCelebritiesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_RecognizeCelebritiesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_RecognizeCelebritiesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_SearchFacesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_SearchFacesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_SearchFacesResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_SearchFacesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_SearchFacesByImageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_SearchFacesByImageCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_SearchFacesByImageResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_SearchFacesByImageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_SearchUsersCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_SearchUsersCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_SearchUsersResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_SearchUsersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_SearchUsersByImageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_SearchUsersByImageCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = de_SearchUsersByImageResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_SearchUsersByImageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ImageTooLargeException":
    case "com.amazonaws.rekognition#ImageTooLargeException":
      throw await de_ImageTooLargeExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidImageFormatException":
    case "com.amazonaws.rekognition#InvalidImageFormatException":
      throw await de_InvalidImageFormatExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartCelebrityRecognitionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartCelebrityRecognitionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartCelebrityRecognitionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartContentModerationCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartContentModerationCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartContentModerationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartFaceDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartFaceDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartFaceDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartFaceSearchCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartFaceSearchCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartFaceSearchCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartLabelDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartLabelDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartLabelDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartMediaAnalysisJobCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartMediaAnalysisJobCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartMediaAnalysisJobCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidManifestException":
    case "com.amazonaws.rekognition#InvalidManifestException":
      throw await de_InvalidManifestExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.rekognition#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartPersonTrackingCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartPersonTrackingCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartPersonTrackingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartProjectVersionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartProjectVersionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartProjectVersionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartSegmentDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartSegmentDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartSegmentDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartStreamProcessorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartStreamProcessorCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartStreamProcessorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StartTextDetectionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StartTextDetectionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StartTextDetectionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.rekognition#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "InvalidS3ObjectException":
    case "com.amazonaws.rekognition#InvalidS3ObjectException":
      throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "VideoTooLargeException":
    case "com.amazonaws.rekognition#VideoTooLargeException":
      throw await de_VideoTooLargeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StopProjectVersionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StopProjectVersionCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StopProjectVersionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_StopStreamProcessorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_StopStreamProcessorCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StopStreamProcessorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_TagResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_TagResourceCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_TagResourceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognition#ServiceQuotaExceededException":
      throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_UntagResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_UntagResourceCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_UntagResourceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_UpdateDatasetEntriesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_UpdateDatasetEntriesCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_UpdateDatasetEntriesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.rekognition#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_UpdateStreamProcessorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_UpdateStreamProcessorCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_UpdateStreamProcessorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognition#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.rekognition#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.rekognition#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.rekognition#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.rekognition#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.rekognition#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.rekognition#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new AccessDeniedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ConflictExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_HumanLoopQuotaExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new HumanLoopQuotaExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_IdempotentParameterMismatchExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new IdempotentParameterMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ImageTooLargeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ImageTooLargeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InternalServerErrorRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InternalServerError({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidImageFormatExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidImageFormatException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidManifestExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidManifestException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidPaginationTokenExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidPaginationTokenException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidParameterException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidPolicyRevisionIdExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidPolicyRevisionIdException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidS3ObjectExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidS3ObjectException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_LimitExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new MalformedPolicyDocumentException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ProvisionedThroughputExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceInUseException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ResourceNotReadyExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceNotReadyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ServiceQuotaExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_SessionNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new SessionNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ThrottlingExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ThrottlingException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_VideoTooLargeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new VideoTooLargeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var se_AssociateFacesRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [true, (_) => _ != null ? _ : v4_default()],
    CollectionId: [],
    FaceIds: _json,
    UserId: [],
    UserMatchThreshold: serializeFloat
  });
};
var se_BlackFrame = (input, context) => {
  return take(input, {
    MaxPixelThreshold: serializeFloat,
    MinCoveragePercentage: serializeFloat
  });
};
var se_BoundingBox = (input, context) => {
  return take(input, {
    Height: serializeFloat,
    Left: serializeFloat,
    Top: serializeFloat,
    Width: serializeFloat
  });
};
var se_CompareFacesRequest = (input, context) => {
  return take(input, {
    QualityFilter: [],
    SimilarityThreshold: serializeFloat,
    SourceImage: (_) => se_Image(_, context),
    TargetImage: (_) => se_Image(_, context)
  });
};
var se_ConnectedHomeSettings = (input, context) => {
  return take(input, {
    Labels: _json,
    MinConfidence: serializeFloat
  });
};
var se_ConnectedHomeSettingsForUpdate = (input, context) => {
  return take(input, {
    Labels: _json,
    MinConfidence: serializeFloat
  });
};
var se_CreateProjectVersionRequest = (input, context) => {
  return take(input, {
    FeatureConfig: (_) => se_CustomizationFeatureConfig(_, context),
    KmsKeyId: [],
    OutputConfig: _json,
    ProjectArn: [],
    Tags: _json,
    TestingData: _json,
    TrainingData: _json,
    VersionDescription: [],
    VersionName: []
  });
};
var se_CreateStreamProcessorRequest = (input, context) => {
  return take(input, {
    DataSharingPreference: _json,
    Input: _json,
    KmsKeyId: [],
    Name: [],
    NotificationChannel: _json,
    Output: _json,
    RegionsOfInterest: (_) => se_RegionsOfInterest(_, context),
    RoleArn: [],
    Settings: (_) => se_StreamProcessorSettings(_, context),
    Tags: _json
  });
};
var se_CreateUserRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [true, (_) => _ != null ? _ : v4_default()],
    CollectionId: [],
    UserId: []
  });
};
var se_CustomizationFeatureConfig = (input, context) => {
  return take(input, {
    ContentModeration: (_) => se_CustomizationFeatureContentModerationConfig(_, context)
  });
};
var se_CustomizationFeatureContentModerationConfig = (input, context) => {
  return take(input, {
    ConfidenceThreshold: serializeFloat
  });
};
var se_DatasetChanges = (input, context) => {
  return take(input, {
    GroundTruth: context.base64Encoder
  });
};
var se_DeleteUserRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [true, (_) => _ != null ? _ : v4_default()],
    CollectionId: [],
    UserId: []
  });
};
var se_DetectCustomLabelsRequest = (input, context) => {
  return take(input, {
    Image: (_) => se_Image(_, context),
    MaxResults: [],
    MinConfidence: serializeFloat,
    ProjectVersionArn: []
  });
};
var se_DetectFacesRequest = (input, context) => {
  return take(input, {
    Attributes: _json,
    Image: (_) => se_Image(_, context)
  });
};
var se_DetectionFilter = (input, context) => {
  return take(input, {
    MinBoundingBoxHeight: serializeFloat,
    MinBoundingBoxWidth: serializeFloat,
    MinConfidence: serializeFloat
  });
};
var se_DetectLabelsRequest = (input, context) => {
  return take(input, {
    Features: _json,
    Image: (_) => se_Image(_, context),
    MaxLabels: [],
    MinConfidence: serializeFloat,
    Settings: _json
  });
};
var se_DetectModerationLabelsRequest = (input, context) => {
  return take(input, {
    HumanLoopConfig: _json,
    Image: (_) => se_Image(_, context),
    MinConfidence: serializeFloat,
    ProjectVersion: []
  });
};
var se_DetectProtectiveEquipmentRequest = (input, context) => {
  return take(input, {
    Image: (_) => se_Image(_, context),
    SummarizationAttributes: (_) => se_ProtectiveEquipmentSummarizationAttributes(_, context)
  });
};
var se_DetectTextFilters = (input, context) => {
  return take(input, {
    RegionsOfInterest: (_) => se_RegionsOfInterest(_, context),
    WordFilter: (_) => se_DetectionFilter(_, context)
  });
};
var se_DetectTextRequest = (input, context) => {
  return take(input, {
    Filters: (_) => se_DetectTextFilters(_, context),
    Image: (_) => se_Image(_, context)
  });
};
var se_DisassociateFacesRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [true, (_) => _ != null ? _ : v4_default()],
    CollectionId: [],
    FaceIds: _json,
    UserId: []
  });
};
var se_FaceSearchSettings = (input, context) => {
  return take(input, {
    CollectionId: [],
    FaceMatchThreshold: serializeFloat
  });
};
var se_Image = (input, context) => {
  return take(input, {
    Bytes: context.base64Encoder,
    S3Object: _json
  });
};
var se_IndexFacesRequest = (input, context) => {
  return take(input, {
    CollectionId: [],
    DetectionAttributes: _json,
    ExternalImageId: [],
    Image: (_) => se_Image(_, context),
    MaxFaces: [],
    QualityFilter: []
  });
};
var se_MediaAnalysisDetectModerationLabelsConfig = (input, context) => {
  return take(input, {
    MinConfidence: serializeFloat,
    ProjectVersion: []
  });
};
var se_MediaAnalysisOperationsConfig = (input, context) => {
  return take(input, {
    DetectModerationLabels: (_) => se_MediaAnalysisDetectModerationLabelsConfig(_, context)
  });
};
var se_Point = (input, context) => {
  return take(input, {
    X: serializeFloat,
    Y: serializeFloat
  });
};
var se_Polygon = (input, context) => {
  return input.filter((e2) => e2 != null).map((entry) => {
    return se_Point(entry, context);
  });
};
var se_ProtectiveEquipmentSummarizationAttributes = (input, context) => {
  return take(input, {
    MinConfidence: serializeFloat,
    RequiredEquipmentTypes: _json
  });
};
var se_RecognizeCelebritiesRequest = (input, context) => {
  return take(input, {
    Image: (_) => se_Image(_, context)
  });
};
var se_RegionOfInterest = (input, context) => {
  return take(input, {
    BoundingBox: (_) => se_BoundingBox(_, context),
    Polygon: (_) => se_Polygon(_, context)
  });
};
var se_RegionsOfInterest = (input, context) => {
  return input.filter((e2) => e2 != null).map((entry) => {
    return se_RegionOfInterest(entry, context);
  });
};
var se_SearchFacesByImageRequest = (input, context) => {
  return take(input, {
    CollectionId: [],
    FaceMatchThreshold: serializeFloat,
    Image: (_) => se_Image(_, context),
    MaxFaces: [],
    QualityFilter: []
  });
};
var se_SearchFacesRequest = (input, context) => {
  return take(input, {
    CollectionId: [],
    FaceId: [],
    FaceMatchThreshold: serializeFloat,
    MaxFaces: []
  });
};
var se_SearchUsersByImageRequest = (input, context) => {
  return take(input, {
    CollectionId: [],
    Image: (_) => se_Image(_, context),
    MaxUsers: [],
    QualityFilter: [],
    UserMatchThreshold: serializeFloat
  });
};
var se_SearchUsersRequest = (input, context) => {
  return take(input, {
    CollectionId: [],
    FaceId: [],
    MaxUsers: [],
    UserId: [],
    UserMatchThreshold: serializeFloat
  });
};
var se_StartContentModerationRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [],
    JobTag: [],
    MinConfidence: serializeFloat,
    NotificationChannel: _json,
    Video: _json
  });
};
var se_StartFaceSearchRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [],
    CollectionId: [],
    FaceMatchThreshold: serializeFloat,
    JobTag: [],
    NotificationChannel: _json,
    Video: _json
  });
};
var se_StartLabelDetectionRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [],
    Features: _json,
    JobTag: [],
    MinConfidence: serializeFloat,
    NotificationChannel: _json,
    Settings: _json,
    Video: _json
  });
};
var se_StartMediaAnalysisJobRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [true, (_) => _ != null ? _ : v4_default()],
    Input: _json,
    JobName: [],
    KmsKeyId: [],
    OperationsConfig: (_) => se_MediaAnalysisOperationsConfig(_, context),
    OutputConfig: _json
  });
};
var se_StartSegmentDetectionFilters = (input, context) => {
  return take(input, {
    ShotFilter: (_) => se_StartShotDetectionFilter(_, context),
    TechnicalCueFilter: (_) => se_StartTechnicalCueDetectionFilter(_, context)
  });
};
var se_StartSegmentDetectionRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [],
    Filters: (_) => se_StartSegmentDetectionFilters(_, context),
    JobTag: [],
    NotificationChannel: _json,
    SegmentTypes: _json,
    Video: _json
  });
};
var se_StartShotDetectionFilter = (input, context) => {
  return take(input, {
    MinSegmentConfidence: serializeFloat
  });
};
var se_StartTechnicalCueDetectionFilter = (input, context) => {
  return take(input, {
    BlackFrame: (_) => se_BlackFrame(_, context),
    MinSegmentConfidence: serializeFloat
  });
};
var se_StartTextDetectionFilters = (input, context) => {
  return take(input, {
    RegionsOfInterest: (_) => se_RegionsOfInterest(_, context),
    WordFilter: (_) => se_DetectionFilter(_, context)
  });
};
var se_StartTextDetectionRequest = (input, context) => {
  return take(input, {
    ClientRequestToken: [],
    Filters: (_) => se_StartTextDetectionFilters(_, context),
    JobTag: [],
    NotificationChannel: _json,
    Video: _json
  });
};
var se_StreamProcessorSettings = (input, context) => {
  return take(input, {
    ConnectedHome: (_) => se_ConnectedHomeSettings(_, context),
    FaceSearch: (_) => se_FaceSearchSettings(_, context)
  });
};
var se_StreamProcessorSettingsForUpdate = (input, context) => {
  return take(input, {
    ConnectedHomeForUpdate: (_) => se_ConnectedHomeSettingsForUpdate(_, context)
  });
};
var se_UpdateDatasetEntriesRequest = (input, context) => {
  return take(input, {
    Changes: (_) => se_DatasetChanges(_, context),
    DatasetArn: []
  });
};
var se_UpdateStreamProcessorRequest = (input, context) => {
  return take(input, {
    DataSharingPreferenceForUpdate: _json,
    Name: [],
    ParametersToDelete: _json,
    RegionsOfInterestForUpdate: (_) => se_RegionsOfInterest(_, context),
    SettingsForUpdate: (_) => se_StreamProcessorSettingsForUpdate(_, context)
  });
};
var de_AssociateFacesResponse = (output, context) => {
  return take(output, {
    AssociatedFaces: _json,
    UnsuccessfulFaceAssociations: (_) => de_UnsuccessfulFaceAssociationList(_, context),
    UserStatus: expectString
  });
};
var de_AuditImage = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Bytes: context.base64Decoder,
    S3Object: _json
  });
};
var de_AuditImages = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_AuditImage(entry, context);
  });
  return retVal;
};
var de_Beard = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_BodyParts = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ProtectiveEquipmentBodyPart(entry, context);
  });
  return retVal;
};
var de_BoundingBox = (output, context) => {
  return take(output, {
    Height: limitedParseFloat32,
    Left: limitedParseFloat32,
    Top: limitedParseFloat32,
    Width: limitedParseFloat32
  });
};
var de_Celebrity = (output, context) => {
  return take(output, {
    Face: (_) => de_ComparedFace(_, context),
    Id: expectString,
    KnownGender: _json,
    MatchConfidence: limitedParseFloat32,
    Name: expectString,
    Urls: _json
  });
};
var de_CelebrityDetail = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    Face: (_) => de_FaceDetail(_, context),
    Id: expectString,
    KnownGender: _json,
    Name: expectString,
    Urls: _json
  });
};
var de_CelebrityList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Celebrity(entry, context);
  });
  return retVal;
};
var de_CelebrityRecognition = (output, context) => {
  return take(output, {
    Celebrity: (_) => de_CelebrityDetail(_, context),
    Timestamp: expectLong
  });
};
var de_CelebrityRecognitions = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_CelebrityRecognition(entry, context);
  });
  return retVal;
};
var de_ComparedFace = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    Emotions: (_) => de_Emotions(_, context),
    Landmarks: (_) => de_Landmarks(_, context),
    Pose: (_) => de_Pose(_, context),
    Quality: (_) => de_ImageQuality(_, context),
    Smile: (_) => de_Smile(_, context)
  });
};
var de_ComparedFaceList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ComparedFace(entry, context);
  });
  return retVal;
};
var de_ComparedSourceImageFace = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32
  });
};
var de_CompareFacesMatch = (output, context) => {
  return take(output, {
    Face: (_) => de_ComparedFace(_, context),
    Similarity: limitedParseFloat32
  });
};
var de_CompareFacesMatchList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_CompareFacesMatch(entry, context);
  });
  return retVal;
};
var de_CompareFacesResponse = (output, context) => {
  return take(output, {
    FaceMatches: (_) => de_CompareFacesMatchList(_, context),
    SourceImageFace: (_) => de_ComparedSourceImageFace(_, context),
    SourceImageOrientationCorrection: expectString,
    TargetImageOrientationCorrection: expectString,
    UnmatchedFaces: (_) => de_CompareFacesUnmatchList(_, context)
  });
};
var de_CompareFacesUnmatchList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ComparedFace(entry, context);
  });
  return retVal;
};
var de_ConnectedHomeSettings = (output, context) => {
  return take(output, {
    Labels: _json,
    MinConfidence: limitedParseFloat32
  });
};
var de_ContentModerationDetection = (output, context) => {
  return take(output, {
    DurationMillis: expectLong,
    EndTimestampMillis: expectLong,
    ModerationLabel: (_) => de_ModerationLabel(_, context),
    StartTimestampMillis: expectLong,
    Timestamp: expectLong
  });
};
var de_ContentModerationDetections = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ContentModerationDetection(entry, context);
  });
  return retVal;
};
var de_CoversBodyPart = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_CustomizationFeatureConfig = (output, context) => {
  return take(output, {
    ContentModeration: (_) => de_CustomizationFeatureContentModerationConfig(_, context)
  });
};
var de_CustomizationFeatureContentModerationConfig = (output, context) => {
  return take(output, {
    ConfidenceThreshold: limitedParseFloat32
  });
};
var de_CustomLabel = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Geometry: (_) => de_Geometry(_, context),
    Name: expectString
  });
};
var de_CustomLabels = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_CustomLabel(entry, context);
  });
  return retVal;
};
var de_DatasetDescription = (output, context) => {
  return take(output, {
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    DatasetStats: _json,
    LastUpdatedTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    Status: expectString,
    StatusMessage: expectString,
    StatusMessageCode: expectString
  });
};
var de_DatasetMetadata = (output, context) => {
  return take(output, {
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    DatasetArn: expectString,
    DatasetType: expectString,
    Status: expectString,
    StatusMessage: expectString,
    StatusMessageCode: expectString
  });
};
var de_DatasetMetadataList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_DatasetMetadata(entry, context);
  });
  return retVal;
};
var de_DescribeCollectionResponse = (output, context) => {
  return take(output, {
    CollectionARN: expectString,
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    FaceCount: expectLong,
    FaceModelVersion: expectString,
    UserCount: expectLong
  });
};
var de_DescribeDatasetResponse = (output, context) => {
  return take(output, {
    DatasetDescription: (_) => de_DatasetDescription(_, context)
  });
};
var de_DescribeProjectsResponse = (output, context) => {
  return take(output, {
    NextToken: expectString,
    ProjectDescriptions: (_) => de_ProjectDescriptions(_, context)
  });
};
var de_DescribeProjectVersionsResponse = (output, context) => {
  return take(output, {
    NextToken: expectString,
    ProjectVersionDescriptions: (_) => de_ProjectVersionDescriptions(_, context)
  });
};
var de_DescribeStreamProcessorResponse = (output, context) => {
  return take(output, {
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    DataSharingPreference: _json,
    Input: _json,
    KmsKeyId: expectString,
    LastUpdateTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    Name: expectString,
    NotificationChannel: _json,
    Output: _json,
    RegionsOfInterest: (_) => de_RegionsOfInterest(_, context),
    RoleArn: expectString,
    Settings: (_) => de_StreamProcessorSettings(_, context),
    Status: expectString,
    StatusMessage: expectString,
    StreamProcessorArn: expectString
  });
};
var de_DetectCustomLabelsResponse = (output, context) => {
  return take(output, {
    CustomLabels: (_) => de_CustomLabels(_, context)
  });
};
var de_DetectFacesResponse = (output, context) => {
  return take(output, {
    FaceDetails: (_) => de_FaceDetailList(_, context),
    OrientationCorrection: expectString
  });
};
var de_DetectLabelsImageBackground = (output, context) => {
  return take(output, {
    DominantColors: (_) => de_DominantColors(_, context),
    Quality: (_) => de_DetectLabelsImageQuality(_, context)
  });
};
var de_DetectLabelsImageForeground = (output, context) => {
  return take(output, {
    DominantColors: (_) => de_DominantColors(_, context),
    Quality: (_) => de_DetectLabelsImageQuality(_, context)
  });
};
var de_DetectLabelsImageProperties = (output, context) => {
  return take(output, {
    Background: (_) => de_DetectLabelsImageBackground(_, context),
    DominantColors: (_) => de_DominantColors(_, context),
    Foreground: (_) => de_DetectLabelsImageForeground(_, context),
    Quality: (_) => de_DetectLabelsImageQuality(_, context)
  });
};
var de_DetectLabelsImageQuality = (output, context) => {
  return take(output, {
    Brightness: limitedParseFloat32,
    Contrast: limitedParseFloat32,
    Sharpness: limitedParseFloat32
  });
};
var de_DetectLabelsResponse = (output, context) => {
  return take(output, {
    ImageProperties: (_) => de_DetectLabelsImageProperties(_, context),
    LabelModelVersion: expectString,
    Labels: (_) => de_Labels(_, context),
    OrientationCorrection: expectString
  });
};
var de_DetectModerationLabelsResponse = (output, context) => {
  return take(output, {
    HumanLoopActivationOutput: (_) => de_HumanLoopActivationOutput(_, context),
    ModerationLabels: (_) => de_ModerationLabels(_, context),
    ModerationModelVersion: expectString,
    ProjectVersion: expectString
  });
};
var de_DetectProtectiveEquipmentResponse = (output, context) => {
  return take(output, {
    Persons: (_) => de_ProtectiveEquipmentPersons(_, context),
    ProtectiveEquipmentModelVersion: expectString,
    Summary: _json
  });
};
var de_DetectTextResponse = (output, context) => {
  return take(output, {
    TextDetections: (_) => de_TextDetectionList(_, context),
    TextModelVersion: expectString
  });
};
var de_DominantColor = (output, context) => {
  return take(output, {
    Blue: expectInt32,
    CSSColor: expectString,
    Green: expectInt32,
    HexCode: expectString,
    PixelPercent: limitedParseFloat32,
    Red: expectInt32,
    SimplifiedColor: expectString
  });
};
var de_DominantColors = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_DominantColor(entry, context);
  });
  return retVal;
};
var de_Emotion = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Type: expectString
  });
};
var de_Emotions = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Emotion(entry, context);
  });
  return retVal;
};
var de_EquipmentDetection = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    CoversBodyPart: (_) => de_CoversBodyPart(_, context),
    Type: expectString
  });
};
var de_EquipmentDetections = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_EquipmentDetection(entry, context);
  });
  return retVal;
};
var de_EvaluationResult = (output, context) => {
  return take(output, {
    F1Score: limitedParseFloat32,
    Summary: _json
  });
};
var de_EyeDirection = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Pitch: limitedParseFloat32,
    Yaw: limitedParseFloat32
  });
};
var de_Eyeglasses = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_EyeOpen = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_Face = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    ExternalImageId: expectString,
    FaceId: expectString,
    ImageId: expectString,
    IndexFacesModelVersion: expectString,
    UserId: expectString
  });
};
var de_FaceDetail = (output, context) => {
  return take(output, {
    AgeRange: _json,
    Beard: (_) => de_Beard(_, context),
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    Emotions: (_) => de_Emotions(_, context),
    EyeDirection: (_) => de_EyeDirection(_, context),
    Eyeglasses: (_) => de_Eyeglasses(_, context),
    EyesOpen: (_) => de_EyeOpen(_, context),
    FaceOccluded: (_) => de_FaceOccluded(_, context),
    Gender: (_) => de_Gender(_, context),
    Landmarks: (_) => de_Landmarks(_, context),
    MouthOpen: (_) => de_MouthOpen(_, context),
    Mustache: (_) => de_Mustache(_, context),
    Pose: (_) => de_Pose(_, context),
    Quality: (_) => de_ImageQuality(_, context),
    Smile: (_) => de_Smile(_, context),
    Sunglasses: (_) => de_Sunglasses(_, context)
  });
};
var de_FaceDetailList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_FaceDetail(entry, context);
  });
  return retVal;
};
var de_FaceDetection = (output, context) => {
  return take(output, {
    Face: (_) => de_FaceDetail(_, context),
    Timestamp: expectLong
  });
};
var de_FaceDetections = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_FaceDetection(entry, context);
  });
  return retVal;
};
var de_FaceList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Face(entry, context);
  });
  return retVal;
};
var de_FaceMatch = (output, context) => {
  return take(output, {
    Face: (_) => de_Face(_, context),
    Similarity: limitedParseFloat32
  });
};
var de_FaceMatchList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_FaceMatch(entry, context);
  });
  return retVal;
};
var de_FaceOccluded = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_FaceRecord = (output, context) => {
  return take(output, {
    Face: (_) => de_Face(_, context),
    FaceDetail: (_) => de_FaceDetail(_, context)
  });
};
var de_FaceRecordList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_FaceRecord(entry, context);
  });
  return retVal;
};
var de_FaceSearchSettings = (output, context) => {
  return take(output, {
    CollectionId: expectString,
    FaceMatchThreshold: limitedParseFloat32
  });
};
var de_Gender = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectString
  });
};
var de_Geometry = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Polygon: (_) => de_Polygon(_, context)
  });
};
var de_GetCelebrityRecognitionResponse = (output, context) => {
  return take(output, {
    Celebrities: (_) => de_CelebrityRecognitions(_, context),
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    NextToken: expectString,
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_GetContentModerationResponse = (output, context) => {
  return take(output, {
    GetRequestMetadata: _json,
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    ModerationLabels: (_) => de_ContentModerationDetections(_, context),
    ModerationModelVersion: expectString,
    NextToken: expectString,
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_GetFaceDetectionResponse = (output, context) => {
  return take(output, {
    Faces: (_) => de_FaceDetections(_, context),
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    NextToken: expectString,
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_GetFaceLivenessSessionResultsResponse = (output, context) => {
  return take(output, {
    AuditImages: (_) => de_AuditImages(_, context),
    Confidence: limitedParseFloat32,
    ReferenceImage: (_) => de_AuditImage(_, context),
    SessionId: expectString,
    Status: expectString
  });
};
var de_GetFaceSearchResponse = (output, context) => {
  return take(output, {
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    NextToken: expectString,
    Persons: (_) => de_PersonMatches(_, context),
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_GetLabelDetectionResponse = (output, context) => {
  return take(output, {
    GetRequestMetadata: _json,
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    LabelModelVersion: expectString,
    Labels: (_) => de_LabelDetections(_, context),
    NextToken: expectString,
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_GetMediaAnalysisJobResponse = (output, context) => {
  return take(output, {
    CompletionTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    FailureDetails: _json,
    Input: _json,
    JobId: expectString,
    JobName: expectString,
    KmsKeyId: expectString,
    ManifestSummary: _json,
    OperationsConfig: (_) => de_MediaAnalysisOperationsConfig(_, context),
    OutputConfig: _json,
    Results: _json,
    Status: expectString
  });
};
var de_GetPersonTrackingResponse = (output, context) => {
  return take(output, {
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    NextToken: expectString,
    Persons: (_) => de_PersonDetections(_, context),
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_GetSegmentDetectionResponse = (output, context) => {
  return take(output, {
    AudioMetadata: _json,
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    NextToken: expectString,
    Segments: (_) => de_SegmentDetections(_, context),
    SelectedSegmentTypes: _json,
    StatusMessage: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadataList(_, context)
  });
};
var de_GetTextDetectionResponse = (output, context) => {
  return take(output, {
    JobId: expectString,
    JobStatus: expectString,
    JobTag: expectString,
    NextToken: expectString,
    StatusMessage: expectString,
    TextDetections: (_) => de_TextDetectionResults(_, context),
    TextModelVersion: expectString,
    Video: _json,
    VideoMetadata: (_) => de_VideoMetadata(_, context)
  });
};
var de_HumanLoopActivationOutput = (output, context) => {
  return take(output, {
    HumanLoopActivationConditionsEvaluationResults: (_) => new LazyJsonString(_),
    HumanLoopActivationReasons: _json,
    HumanLoopArn: expectString
  });
};
var de_ImageQuality = (output, context) => {
  return take(output, {
    Brightness: limitedParseFloat32,
    Sharpness: limitedParseFloat32
  });
};
var de_IndexFacesResponse = (output, context) => {
  return take(output, {
    FaceModelVersion: expectString,
    FaceRecords: (_) => de_FaceRecordList(_, context),
    OrientationCorrection: expectString,
    UnindexedFaces: (_) => de_UnindexedFaces(_, context)
  });
};
var de_Instance = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    DominantColors: (_) => de_DominantColors(_, context)
  });
};
var de_Instances = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Instance(entry, context);
  });
  return retVal;
};
var de_Label = (output, context) => {
  return take(output, {
    Aliases: _json,
    Categories: _json,
    Confidence: limitedParseFloat32,
    Instances: (_) => de_Instances(_, context),
    Name: expectString,
    Parents: _json
  });
};
var de_LabelDetection = (output, context) => {
  return take(output, {
    DurationMillis: expectLong,
    EndTimestampMillis: expectLong,
    Label: (_) => de_Label(_, context),
    StartTimestampMillis: expectLong,
    Timestamp: expectLong
  });
};
var de_LabelDetections = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_LabelDetection(entry, context);
  });
  return retVal;
};
var de_Labels = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Label(entry, context);
  });
  return retVal;
};
var de_Landmark = (output, context) => {
  return take(output, {
    Type: expectString,
    X: limitedParseFloat32,
    Y: limitedParseFloat32
  });
};
var de_Landmarks = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Landmark(entry, context);
  });
  return retVal;
};
var de_ListFacesResponse = (output, context) => {
  return take(output, {
    FaceModelVersion: expectString,
    Faces: (_) => de_FaceList(_, context),
    NextToken: expectString
  });
};
var de_ListMediaAnalysisJobsResponse = (output, context) => {
  return take(output, {
    MediaAnalysisJobs: (_) => de_MediaAnalysisJobDescriptions(_, context),
    NextToken: expectString
  });
};
var de_ListProjectPoliciesResponse = (output, context) => {
  return take(output, {
    NextToken: expectString,
    ProjectPolicies: (_) => de_ProjectPolicies(_, context)
  });
};
var de_MediaAnalysisDetectModerationLabelsConfig = (output, context) => {
  return take(output, {
    MinConfidence: limitedParseFloat32,
    ProjectVersion: expectString
  });
};
var de_MediaAnalysisJobDescription = (output, context) => {
  return take(output, {
    CompletionTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    FailureDetails: _json,
    Input: _json,
    JobId: expectString,
    JobName: expectString,
    KmsKeyId: expectString,
    ManifestSummary: _json,
    OperationsConfig: (_) => de_MediaAnalysisOperationsConfig(_, context),
    OutputConfig: _json,
    Results: _json,
    Status: expectString
  });
};
var de_MediaAnalysisJobDescriptions = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MediaAnalysisJobDescription(entry, context);
  });
  return retVal;
};
var de_MediaAnalysisOperationsConfig = (output, context) => {
  return take(output, {
    DetectModerationLabels: (_) => de_MediaAnalysisDetectModerationLabelsConfig(_, context)
  });
};
var de_ModerationLabel = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Name: expectString,
    ParentName: expectString
  });
};
var de_ModerationLabels = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ModerationLabel(entry, context);
  });
  return retVal;
};
var de_MouthOpen = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_Mustache = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_PersonDetail = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Face: (_) => de_FaceDetail(_, context),
    Index: expectLong
  });
};
var de_PersonDetection = (output, context) => {
  return take(output, {
    Person: (_) => de_PersonDetail(_, context),
    Timestamp: expectLong
  });
};
var de_PersonDetections = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_PersonDetection(entry, context);
  });
  return retVal;
};
var de_PersonMatch = (output, context) => {
  return take(output, {
    FaceMatches: (_) => de_FaceMatchList(_, context),
    Person: (_) => de_PersonDetail(_, context),
    Timestamp: expectLong
  });
};
var de_PersonMatches = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_PersonMatch(entry, context);
  });
  return retVal;
};
var de_Point = (output, context) => {
  return take(output, {
    X: limitedParseFloat32,
    Y: limitedParseFloat32
  });
};
var de_Polygon = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Point(entry, context);
  });
  return retVal;
};
var de_Pose = (output, context) => {
  return take(output, {
    Pitch: limitedParseFloat32,
    Roll: limitedParseFloat32,
    Yaw: limitedParseFloat32
  });
};
var de_ProjectDescription = (output, context) => {
  return take(output, {
    AutoUpdate: expectString,
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    Datasets: (_) => de_DatasetMetadataList(_, context),
    Feature: expectString,
    ProjectArn: expectString,
    Status: expectString
  });
};
var de_ProjectDescriptions = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ProjectDescription(entry, context);
  });
  return retVal;
};
var de_ProjectPolicies = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ProjectPolicy(entry, context);
  });
  return retVal;
};
var de_ProjectPolicy = (output, context) => {
  return take(output, {
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    LastUpdatedTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    PolicyDocument: expectString,
    PolicyName: expectString,
    PolicyRevisionId: expectString,
    ProjectArn: expectString
  });
};
var de_ProjectVersionDescription = (output, context) => {
  return take(output, {
    BaseModelVersion: expectString,
    BillableTrainingTimeInSeconds: expectLong,
    CreationTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    EvaluationResult: (_) => de_EvaluationResult(_, context),
    Feature: expectString,
    FeatureConfig: (_) => de_CustomizationFeatureConfig(_, context),
    KmsKeyId: expectString,
    ManifestSummary: _json,
    MaxInferenceUnits: expectInt32,
    MinInferenceUnits: expectInt32,
    OutputConfig: _json,
    ProjectVersionArn: expectString,
    SourceProjectVersionArn: expectString,
    Status: expectString,
    StatusMessage: expectString,
    TestingDataResult: _json,
    TrainingDataResult: _json,
    TrainingEndTimestamp: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    VersionDescription: expectString
  });
};
var de_ProjectVersionDescriptions = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ProjectVersionDescription(entry, context);
  });
  return retVal;
};
var de_ProtectiveEquipmentBodyPart = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    EquipmentDetections: (_) => de_EquipmentDetections(_, context),
    Name: expectString
  });
};
var de_ProtectiveEquipmentPerson = (output, context) => {
  return take(output, {
    BodyParts: (_) => de_BodyParts(_, context),
    BoundingBox: (_) => de_BoundingBox(_, context),
    Confidence: limitedParseFloat32,
    Id: expectInt32
  });
};
var de_ProtectiveEquipmentPersons = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ProtectiveEquipmentPerson(entry, context);
  });
  return retVal;
};
var de_RecognizeCelebritiesResponse = (output, context) => {
  return take(output, {
    CelebrityFaces: (_) => de_CelebrityList(_, context),
    OrientationCorrection: expectString,
    UnrecognizedFaces: (_) => de_ComparedFaceList(_, context)
  });
};
var de_RegionOfInterest = (output, context) => {
  return take(output, {
    BoundingBox: (_) => de_BoundingBox(_, context),
    Polygon: (_) => de_Polygon(_, context)
  });
};
var de_RegionsOfInterest = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_RegionOfInterest(entry, context);
  });
  return retVal;
};
var de_SearchedFaceDetails = (output, context) => {
  return take(output, {
    FaceDetail: (_) => de_FaceDetail(_, context)
  });
};
var de_SearchFacesByImageResponse = (output, context) => {
  return take(output, {
    FaceMatches: (_) => de_FaceMatchList(_, context),
    FaceModelVersion: expectString,
    SearchedFaceBoundingBox: (_) => de_BoundingBox(_, context),
    SearchedFaceConfidence: limitedParseFloat32
  });
};
var de_SearchFacesResponse = (output, context) => {
  return take(output, {
    FaceMatches: (_) => de_FaceMatchList(_, context),
    FaceModelVersion: expectString,
    SearchedFaceId: expectString
  });
};
var de_SearchUsersByImageResponse = (output, context) => {
  return take(output, {
    FaceModelVersion: expectString,
    SearchedFace: (_) => de_SearchedFaceDetails(_, context),
    UnsearchedFaces: (_) => de_UnsearchedFacesList(_, context),
    UserMatches: (_) => de_UserMatchList(_, context)
  });
};
var de_SearchUsersResponse = (output, context) => {
  return take(output, {
    FaceModelVersion: expectString,
    SearchedFace: _json,
    SearchedUser: _json,
    UserMatches: (_) => de_UserMatchList(_, context)
  });
};
var de_SegmentDetection = (output, context) => {
  return take(output, {
    DurationFrames: expectLong,
    DurationMillis: expectLong,
    DurationSMPTE: expectString,
    EndFrameNumber: expectLong,
    EndTimecodeSMPTE: expectString,
    EndTimestampMillis: expectLong,
    ShotSegment: (_) => de_ShotSegment(_, context),
    StartFrameNumber: expectLong,
    StartTimecodeSMPTE: expectString,
    StartTimestampMillis: expectLong,
    TechnicalCueSegment: (_) => de_TechnicalCueSegment(_, context),
    Type: expectString
  });
};
var de_SegmentDetections = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_SegmentDetection(entry, context);
  });
  return retVal;
};
var de_ShotSegment = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Index: expectLong
  });
};
var de_Smile = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_StreamProcessorSettings = (output, context) => {
  return take(output, {
    ConnectedHome: (_) => de_ConnectedHomeSettings(_, context),
    FaceSearch: (_) => de_FaceSearchSettings(_, context)
  });
};
var de_Sunglasses = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Value: expectBoolean
  });
};
var de_TechnicalCueSegment = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    Type: expectString
  });
};
var de_TextDetection = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    DetectedText: expectString,
    Geometry: (_) => de_Geometry(_, context),
    Id: expectInt32,
    ParentId: expectInt32,
    Type: expectString
  });
};
var de_TextDetectionList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_TextDetection(entry, context);
  });
  return retVal;
};
var de_TextDetectionResult = (output, context) => {
  return take(output, {
    TextDetection: (_) => de_TextDetection(_, context),
    Timestamp: expectLong
  });
};
var de_TextDetectionResults = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_TextDetectionResult(entry, context);
  });
  return retVal;
};
var de_UnindexedFace = (output, context) => {
  return take(output, {
    FaceDetail: (_) => de_FaceDetail(_, context),
    Reasons: _json
  });
};
var de_UnindexedFaces = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_UnindexedFace(entry, context);
  });
  return retVal;
};
var de_UnsearchedFace = (output, context) => {
  return take(output, {
    FaceDetails: (_) => de_FaceDetail(_, context),
    Reasons: _json
  });
};
var de_UnsearchedFacesList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_UnsearchedFace(entry, context);
  });
  return retVal;
};
var de_UnsuccessfulFaceAssociation = (output, context) => {
  return take(output, {
    Confidence: limitedParseFloat32,
    FaceId: expectString,
    Reasons: _json,
    UserId: expectString
  });
};
var de_UnsuccessfulFaceAssociationList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_UnsuccessfulFaceAssociation(entry, context);
  });
  return retVal;
};
var de_UserMatch = (output, context) => {
  return take(output, {
    Similarity: limitedParseFloat32,
    User: _json
  });
};
var de_UserMatchList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_UserMatch(entry, context);
  });
  return retVal;
};
var de_VideoMetadata = (output, context) => {
  return take(output, {
    Codec: expectString,
    ColorRange: expectString,
    DurationMillis: expectLong,
    Format: expectString,
    FrameHeight: expectLong,
    FrameRate: limitedParseFloat32,
    FrameWidth: expectLong
  });
};
var de_VideoMetadataList = (output, context) => {
  const retVal = (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_VideoMetadata(entry, context);
  });
  return retVal;
};
var deserializeMetadata = (output) => {
  var _a, _b;
  return {
    httpStatusCode: output.statusCode,
    requestId: (_b = (_a = output.headers["x-amzn-requestid"]) != null ? _a : output.headers["x-amzn-request-id"]) != null ? _b : output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  };
};
var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
var throwDefaultError = withBaseException(RekognitionServiceException);
var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
function sharedHeaders(operation) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `RekognitionService.${operation}`
  };
}
var parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody = async (errorBody, context) => {
  var _a;
  const value = await parseBody(errorBody, context);
  value.message = (_a = value.message) != null ? _a : value.Message;
  return value;
};
var loadRestJsonErrorCode = (output, data) => {
  const findKey = (object, key) => Object.keys(object).find((k2) => k2.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/AssociateFacesCommand.js
var AssociateFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, AssociateFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "AssociateFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "AssociateFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_AssociateFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_AssociateFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CompareFacesCommand.js
var CompareFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CompareFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CompareFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CompareFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CompareFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_CompareFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CopyProjectVersionCommand.js
var CopyProjectVersionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CopyProjectVersionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CopyProjectVersionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CopyProjectVersion"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CopyProjectVersionCommand(input, context);
  }
  deserialize(output, context) {
    return de_CopyProjectVersionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateCollectionCommand.js
var CreateCollectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateCollectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateCollectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateCollection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateCollectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateCollectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateDatasetCommand.js
var CreateDatasetCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateDatasetCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateDatasetCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateDataset"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateDatasetCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateDatasetCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateFaceLivenessSessionCommand.js
var CreateFaceLivenessSessionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateFaceLivenessSessionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateFaceLivenessSessionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateFaceLivenessSession"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateFaceLivenessSessionCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateFaceLivenessSessionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateProjectCommand.js
var CreateProjectCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateProjectCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateProjectCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateProject"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateProjectCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateProjectCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateProjectVersionCommand.js
var CreateProjectVersionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateProjectVersionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateProjectVersionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateProjectVersion"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateProjectVersionCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateProjectVersionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateStreamProcessorCommand.js
var CreateStreamProcessorCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateStreamProcessorCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateStreamProcessorCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateStreamProcessor"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateStreamProcessorCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateStreamProcessorCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/CreateUserCommand.js
var CreateUserCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateUserCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "CreateUserCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "CreateUser"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateUserCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateUserCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteCollectionCommand.js
var DeleteCollectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteCollectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteCollectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteCollection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteCollectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteCollectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteDatasetCommand.js
var DeleteDatasetCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteDatasetCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteDatasetCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteDataset"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteDatasetCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteDatasetCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteFacesCommand.js
var DeleteFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteProjectCommand.js
var DeleteProjectCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteProjectCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteProjectCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteProject"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteProjectCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteProjectCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteProjectPolicyCommand.js
var DeleteProjectPolicyCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteProjectPolicyCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteProjectPolicyCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteProjectPolicy"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteProjectPolicyCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteProjectPolicyCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteProjectVersionCommand.js
var DeleteProjectVersionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteProjectVersionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteProjectVersionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteProjectVersion"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteProjectVersionCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteProjectVersionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteStreamProcessorCommand.js
var DeleteStreamProcessorCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteStreamProcessorCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteStreamProcessorCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteStreamProcessor"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteStreamProcessorCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteStreamProcessorCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DeleteUserCommand.js
var DeleteUserCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteUserCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DeleteUserCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DeleteUser"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteUserCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteUserCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DescribeCollectionCommand.js
var DescribeCollectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DescribeCollectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DescribeCollectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DescribeCollection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DescribeCollectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_DescribeCollectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DescribeDatasetCommand.js
var DescribeDatasetCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DescribeDatasetCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DescribeDatasetCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DescribeDataset"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DescribeDatasetCommand(input, context);
  }
  deserialize(output, context) {
    return de_DescribeDatasetCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DescribeProjectsCommand.js
var DescribeProjectsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DescribeProjectsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DescribeProjectsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DescribeProjects"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DescribeProjectsCommand(input, context);
  }
  deserialize(output, context) {
    return de_DescribeProjectsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DescribeProjectVersionsCommand.js
var DescribeProjectVersionsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DescribeProjectVersionsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DescribeProjectVersionsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DescribeProjectVersions"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DescribeProjectVersionsCommand(input, context);
  }
  deserialize(output, context) {
    return de_DescribeProjectVersionsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DescribeStreamProcessorCommand.js
var DescribeStreamProcessorCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DescribeStreamProcessorCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DescribeStreamProcessorCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DescribeStreamProcessor"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DescribeStreamProcessorCommand(input, context);
  }
  deserialize(output, context) {
    return de_DescribeStreamProcessorCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DetectCustomLabelsCommand.js
var DetectCustomLabelsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DetectCustomLabelsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DetectCustomLabelsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DetectCustomLabels"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DetectCustomLabelsCommand(input, context);
  }
  deserialize(output, context) {
    return de_DetectCustomLabelsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DetectFacesCommand.js
var DetectFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DetectFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DetectFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DetectFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DetectFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_DetectFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DetectLabelsCommand.js
var DetectLabelsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DetectLabelsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DetectLabelsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DetectLabels"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DetectLabelsCommand(input, context);
  }
  deserialize(output, context) {
    return de_DetectLabelsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DetectModerationLabelsCommand.js
var DetectModerationLabelsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DetectModerationLabelsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DetectModerationLabelsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DetectModerationLabels"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DetectModerationLabelsCommand(input, context);
  }
  deserialize(output, context) {
    return de_DetectModerationLabelsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DetectProtectiveEquipmentCommand.js
var DetectProtectiveEquipmentCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DetectProtectiveEquipmentCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DetectProtectiveEquipmentCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DetectProtectiveEquipment"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DetectProtectiveEquipmentCommand(input, context);
  }
  deserialize(output, context) {
    return de_DetectProtectiveEquipmentCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DetectTextCommand.js
var DetectTextCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DetectTextCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DetectTextCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DetectText"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DetectTextCommand(input, context);
  }
  deserialize(output, context) {
    return de_DetectTextCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DisassociateFacesCommand.js
var DisassociateFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DisassociateFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DisassociateFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DisassociateFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DisassociateFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_DisassociateFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/DistributeDatasetEntriesCommand.js
var DistributeDatasetEntriesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DistributeDatasetEntriesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "DistributeDatasetEntriesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "DistributeDatasetEntries"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DistributeDatasetEntriesCommand(input, context);
  }
  deserialize(output, context) {
    return de_DistributeDatasetEntriesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetCelebrityInfoCommand.js
var GetCelebrityInfoCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetCelebrityInfoCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetCelebrityInfoCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetCelebrityInfo"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetCelebrityInfoCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetCelebrityInfoCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetCelebrityRecognitionCommand.js
var GetCelebrityRecognitionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetCelebrityRecognitionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetCelebrityRecognitionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetCelebrityRecognition"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetCelebrityRecognitionCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetCelebrityRecognitionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetContentModerationCommand.js
var GetContentModerationCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetContentModerationCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetContentModerationCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetContentModeration"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetContentModerationCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetContentModerationCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetFaceDetectionCommand.js
var GetFaceDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetFaceDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetFaceDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetFaceDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetFaceDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetFaceDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetFaceLivenessSessionResultsCommand.js
var GetFaceLivenessSessionResultsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetFaceLivenessSessionResultsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetFaceLivenessSessionResultsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: GetFaceLivenessSessionResultsResponseFilterSensitiveLog,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetFaceLivenessSessionResults"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetFaceLivenessSessionResultsCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetFaceLivenessSessionResultsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetFaceSearchCommand.js
var GetFaceSearchCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetFaceSearchCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetFaceSearchCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetFaceSearch"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetFaceSearchCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetFaceSearchCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetLabelDetectionCommand.js
var GetLabelDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetLabelDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetLabelDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetLabelDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetLabelDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetLabelDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetMediaAnalysisJobCommand.js
var GetMediaAnalysisJobCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetMediaAnalysisJobCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetMediaAnalysisJobCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetMediaAnalysisJob"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetMediaAnalysisJobCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetMediaAnalysisJobCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetPersonTrackingCommand.js
var GetPersonTrackingCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetPersonTrackingCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetPersonTrackingCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetPersonTracking"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetPersonTrackingCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetPersonTrackingCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetSegmentDetectionCommand.js
var GetSegmentDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetSegmentDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetSegmentDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetSegmentDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetSegmentDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetSegmentDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/GetTextDetectionCommand.js
var GetTextDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetTextDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "GetTextDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "GetTextDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetTextDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetTextDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/IndexFacesCommand.js
var IndexFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, IndexFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "IndexFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "IndexFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_IndexFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_IndexFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListCollectionsCommand.js
var ListCollectionsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListCollectionsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListCollectionsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListCollections"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListCollectionsCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListCollectionsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListDatasetEntriesCommand.js
var ListDatasetEntriesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListDatasetEntriesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListDatasetEntriesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListDatasetEntries"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListDatasetEntriesCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListDatasetEntriesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListDatasetLabelsCommand.js
var ListDatasetLabelsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListDatasetLabelsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListDatasetLabelsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListDatasetLabels"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListDatasetLabelsCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListDatasetLabelsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListFacesCommand.js
var ListFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListMediaAnalysisJobsCommand.js
var ListMediaAnalysisJobsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListMediaAnalysisJobsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListMediaAnalysisJobsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListMediaAnalysisJobs"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListMediaAnalysisJobsCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListMediaAnalysisJobsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListProjectPoliciesCommand.js
var ListProjectPoliciesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListProjectPoliciesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListProjectPoliciesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListProjectPolicies"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListProjectPoliciesCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListProjectPoliciesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListStreamProcessorsCommand.js
var ListStreamProcessorsCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListStreamProcessorsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListStreamProcessorsCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListStreamProcessors"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListStreamProcessorsCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListStreamProcessorsCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListTagsForResourceCommand.js
var ListTagsForResourceCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListTagsForResourceCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListTagsForResource"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListTagsForResourceCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListTagsForResourceCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/ListUsersCommand.js
var ListUsersCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListUsersCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "ListUsersCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "ListUsers"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_ListUsersCommand(input, context);
  }
  deserialize(output, context) {
    return de_ListUsersCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/PutProjectPolicyCommand.js
var PutProjectPolicyCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, PutProjectPolicyCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "PutProjectPolicyCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "PutProjectPolicy"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_PutProjectPolicyCommand(input, context);
  }
  deserialize(output, context) {
    return de_PutProjectPolicyCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/RecognizeCelebritiesCommand.js
var RecognizeCelebritiesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, RecognizeCelebritiesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "RecognizeCelebritiesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "RecognizeCelebrities"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_RecognizeCelebritiesCommand(input, context);
  }
  deserialize(output, context) {
    return de_RecognizeCelebritiesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/SearchFacesByImageCommand.js
var SearchFacesByImageCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, SearchFacesByImageCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "SearchFacesByImageCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "SearchFacesByImage"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_SearchFacesByImageCommand(input, context);
  }
  deserialize(output, context) {
    return de_SearchFacesByImageCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/SearchFacesCommand.js
var SearchFacesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, SearchFacesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "SearchFacesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "SearchFaces"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_SearchFacesCommand(input, context);
  }
  deserialize(output, context) {
    return de_SearchFacesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/SearchUsersByImageCommand.js
var SearchUsersByImageCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, SearchUsersByImageCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "SearchUsersByImageCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "SearchUsersByImage"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_SearchUsersByImageCommand(input, context);
  }
  deserialize(output, context) {
    return de_SearchUsersByImageCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/SearchUsersCommand.js
var SearchUsersCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, SearchUsersCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "SearchUsersCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "SearchUsers"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_SearchUsersCommand(input, context);
  }
  deserialize(output, context) {
    return de_SearchUsersCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartCelebrityRecognitionCommand.js
var StartCelebrityRecognitionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartCelebrityRecognitionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartCelebrityRecognitionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartCelebrityRecognition"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartCelebrityRecognitionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartCelebrityRecognitionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartContentModerationCommand.js
var StartContentModerationCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartContentModerationCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartContentModerationCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartContentModeration"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartContentModerationCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartContentModerationCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartFaceDetectionCommand.js
var StartFaceDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartFaceDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartFaceDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartFaceDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartFaceDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartFaceDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartFaceSearchCommand.js
var StartFaceSearchCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartFaceSearchCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartFaceSearchCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartFaceSearch"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartFaceSearchCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartFaceSearchCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartLabelDetectionCommand.js
var StartLabelDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartLabelDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartLabelDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartLabelDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartLabelDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartLabelDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartMediaAnalysisJobCommand.js
var StartMediaAnalysisJobCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartMediaAnalysisJobCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartMediaAnalysisJobCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartMediaAnalysisJob"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartMediaAnalysisJobCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartMediaAnalysisJobCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartPersonTrackingCommand.js
var StartPersonTrackingCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartPersonTrackingCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartPersonTrackingCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartPersonTracking"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartPersonTrackingCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartPersonTrackingCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartProjectVersionCommand.js
var StartProjectVersionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartProjectVersionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartProjectVersionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartProjectVersion"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartProjectVersionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartProjectVersionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartSegmentDetectionCommand.js
var StartSegmentDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartSegmentDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartSegmentDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartSegmentDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartSegmentDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartSegmentDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartStreamProcessorCommand.js
var StartStreamProcessorCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartStreamProcessorCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartStreamProcessorCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartStreamProcessor"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartStreamProcessorCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartStreamProcessorCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StartTextDetectionCommand.js
var StartTextDetectionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StartTextDetectionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StartTextDetectionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StartTextDetection"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StartTextDetectionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StartTextDetectionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StopProjectVersionCommand.js
var StopProjectVersionCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StopProjectVersionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StopProjectVersionCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StopProjectVersion"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StopProjectVersionCommand(input, context);
  }
  deserialize(output, context) {
    return de_StopProjectVersionCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/StopStreamProcessorCommand.js
var StopStreamProcessorCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, StopStreamProcessorCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "StopStreamProcessorCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "StopStreamProcessor"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_StopStreamProcessorCommand(input, context);
  }
  deserialize(output, context) {
    return de_StopStreamProcessorCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/TagResourceCommand.js
var TagResourceCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, TagResourceCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "TagResourceCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "TagResource"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_TagResourceCommand(input, context);
  }
  deserialize(output, context) {
    return de_TagResourceCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/UntagResourceCommand.js
var UntagResourceCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "UntagResourceCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "UntagResource"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_UntagResourceCommand(input, context);
  }
  deserialize(output, context) {
    return de_UntagResourceCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/UpdateDatasetEntriesCommand.js
var UpdateDatasetEntriesCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, UpdateDatasetEntriesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "UpdateDatasetEntriesCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "UpdateDatasetEntries"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_UpdateDatasetEntriesCommand(input, context);
  }
  deserialize(output, context) {
    return de_UpdateDatasetEntriesCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/commands/UpdateStreamProcessorCommand.js
var UpdateStreamProcessorCommand = class extends Command {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, UpdateStreamProcessorCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "RekognitionClient";
    const commandName = "UpdateStreamProcessorCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _,
      [SMITHY_CONTEXT_KEY]: {
        service: "RekognitionService",
        operation: "UpdateStreamProcessor"
      }
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_UpdateStreamProcessorCommand(input, context);
  }
  deserialize(output, context) {
    return de_UpdateStreamProcessorCommand(output, context);
  }
};

// node_modules/@aws-sdk/client-rekognition/dist-es/Rekognition.js
var commands = {
  AssociateFacesCommand,
  CompareFacesCommand,
  CopyProjectVersionCommand,
  CreateCollectionCommand,
  CreateDatasetCommand,
  CreateFaceLivenessSessionCommand,
  CreateProjectCommand,
  CreateProjectVersionCommand,
  CreateStreamProcessorCommand,
  CreateUserCommand,
  DeleteCollectionCommand,
  DeleteDatasetCommand,
  DeleteFacesCommand,
  DeleteProjectCommand,
  DeleteProjectPolicyCommand,
  DeleteProjectVersionCommand,
  DeleteStreamProcessorCommand,
  DeleteUserCommand,
  DescribeCollectionCommand,
  DescribeDatasetCommand,
  DescribeProjectsCommand,
  DescribeProjectVersionsCommand,
  DescribeStreamProcessorCommand,
  DetectCustomLabelsCommand,
  DetectFacesCommand,
  DetectLabelsCommand,
  DetectModerationLabelsCommand,
  DetectProtectiveEquipmentCommand,
  DetectTextCommand,
  DisassociateFacesCommand,
  DistributeDatasetEntriesCommand,
  GetCelebrityInfoCommand,
  GetCelebrityRecognitionCommand,
  GetContentModerationCommand,
  GetFaceDetectionCommand,
  GetFaceLivenessSessionResultsCommand,
  GetFaceSearchCommand,
  GetLabelDetectionCommand,
  GetMediaAnalysisJobCommand,
  GetPersonTrackingCommand,
  GetSegmentDetectionCommand,
  GetTextDetectionCommand,
  IndexFacesCommand,
  ListCollectionsCommand,
  ListDatasetEntriesCommand,
  ListDatasetLabelsCommand,
  ListFacesCommand,
  ListMediaAnalysisJobsCommand,
  ListProjectPoliciesCommand,
  ListStreamProcessorsCommand,
  ListTagsForResourceCommand,
  ListUsersCommand,
  PutProjectPolicyCommand,
  RecognizeCelebritiesCommand,
  SearchFacesCommand,
  SearchFacesByImageCommand,
  SearchUsersCommand,
  SearchUsersByImageCommand,
  StartCelebrityRecognitionCommand,
  StartContentModerationCommand,
  StartFaceDetectionCommand,
  StartFaceSearchCommand,
  StartLabelDetectionCommand,
  StartMediaAnalysisJobCommand,
  StartPersonTrackingCommand,
  StartProjectVersionCommand,
  StartSegmentDetectionCommand,
  StartStreamProcessorCommand,
  StartTextDetectionCommand,
  StopProjectVersionCommand,
  StopStreamProcessorCommand,
  TagResourceCommand,
  UntagResourceCommand,
  UpdateDatasetEntriesCommand,
  UpdateStreamProcessorCommand
};
var Rekognition = class extends RekognitionClient {
};
createAggregatedClient(commands, Rekognition);

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/DescribeProjectVersionsPaginator.js
var makePagedClientRequest = async (client, input, ...args) => {
  return await client.send(new DescribeProjectVersionsCommand(input), ...args);
};
async function* paginateDescribeProjectVersions(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/DescribeProjectsPaginator.js
var makePagedClientRequest2 = async (client, input, ...args) => {
  return await client.send(new DescribeProjectsCommand(input), ...args);
};
async function* paginateDescribeProjects(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest2(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetCelebrityRecognitionPaginator.js
var makePagedClientRequest3 = async (client, input, ...args) => {
  return await client.send(new GetCelebrityRecognitionCommand(input), ...args);
};
async function* paginateGetCelebrityRecognition(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest3(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetContentModerationPaginator.js
var makePagedClientRequest4 = async (client, input, ...args) => {
  return await client.send(new GetContentModerationCommand(input), ...args);
};
async function* paginateGetContentModeration(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest4(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetFaceDetectionPaginator.js
var makePagedClientRequest5 = async (client, input, ...args) => {
  return await client.send(new GetFaceDetectionCommand(input), ...args);
};
async function* paginateGetFaceDetection(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest5(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetFaceSearchPaginator.js
var makePagedClientRequest6 = async (client, input, ...args) => {
  return await client.send(new GetFaceSearchCommand(input), ...args);
};
async function* paginateGetFaceSearch(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest6(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetLabelDetectionPaginator.js
var makePagedClientRequest7 = async (client, input, ...args) => {
  return await client.send(new GetLabelDetectionCommand(input), ...args);
};
async function* paginateGetLabelDetection(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest7(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetPersonTrackingPaginator.js
var makePagedClientRequest8 = async (client, input, ...args) => {
  return await client.send(new GetPersonTrackingCommand(input), ...args);
};
async function* paginateGetPersonTracking(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest8(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetSegmentDetectionPaginator.js
var makePagedClientRequest9 = async (client, input, ...args) => {
  return await client.send(new GetSegmentDetectionCommand(input), ...args);
};
async function* paginateGetSegmentDetection(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest9(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/GetTextDetectionPaginator.js
var makePagedClientRequest10 = async (client, input, ...args) => {
  return await client.send(new GetTextDetectionCommand(input), ...args);
};
async function* paginateGetTextDetection(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest10(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListCollectionsPaginator.js
var makePagedClientRequest11 = async (client, input, ...args) => {
  return await client.send(new ListCollectionsCommand(input), ...args);
};
async function* paginateListCollections(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest11(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListDatasetEntriesPaginator.js
var makePagedClientRequest12 = async (client, input, ...args) => {
  return await client.send(new ListDatasetEntriesCommand(input), ...args);
};
async function* paginateListDatasetEntries(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest12(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListDatasetLabelsPaginator.js
var makePagedClientRequest13 = async (client, input, ...args) => {
  return await client.send(new ListDatasetLabelsCommand(input), ...args);
};
async function* paginateListDatasetLabels(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest13(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListFacesPaginator.js
var makePagedClientRequest14 = async (client, input, ...args) => {
  return await client.send(new ListFacesCommand(input), ...args);
};
async function* paginateListFaces(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest14(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListMediaAnalysisJobsPaginator.js
var makePagedClientRequest15 = async (client, input, ...args) => {
  return await client.send(new ListMediaAnalysisJobsCommand(input), ...args);
};
async function* paginateListMediaAnalysisJobs(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest15(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListProjectPoliciesPaginator.js
var makePagedClientRequest16 = async (client, input, ...args) => {
  return await client.send(new ListProjectPoliciesCommand(input), ...args);
};
async function* paginateListProjectPolicies(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest16(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListStreamProcessorsPaginator.js
var makePagedClientRequest17 = async (client, input, ...args) => {
  return await client.send(new ListStreamProcessorsCommand(input), ...args);
};
async function* paginateListStreamProcessors(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest17(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@aws-sdk/client-rekognition/dist-es/pagination/ListUsersPaginator.js
var makePagedClientRequest18 = async (client, input, ...args) => {
  return await client.send(new ListUsersCommand(input), ...args);
};
async function* paginateListUsers(config, input, ...additionalArguments) {
  let token = config.startingToken || void 0;
  let hasNext = true;
  let page;
  while (hasNext) {
    input.NextToken = token;
    input["MaxResults"] = config.pageSize;
    if (config.client instanceof RekognitionClient) {
      page = await makePagedClientRequest18(config.client, input, ...additionalArguments);
    } else {
      throw new Error("Invalid client, expected Rekognition | RekognitionClient");
    }
    yield page;
    const prevToken = token;
    token = page.NextToken;
    hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
  }
  return void 0;
}

// node_modules/@smithy/util-waiter/dist-es/utils/sleep.js
var sleep = (seconds) => {
  return new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
};

// node_modules/@smithy/util-waiter/dist-es/waiter.js
var waiterServiceDefaults = {
  minDelay: 2,
  maxDelay: 120
};
var WaiterState;
(function(WaiterState2) {
  WaiterState2["ABORTED"] = "ABORTED";
  WaiterState2["FAILURE"] = "FAILURE";
  WaiterState2["SUCCESS"] = "SUCCESS";
  WaiterState2["RETRY"] = "RETRY";
  WaiterState2["TIMEOUT"] = "TIMEOUT";
})(WaiterState || (WaiterState = {}));
var checkExceptions = (result) => {
  if (result.state === WaiterState.ABORTED) {
    const abortError = new Error(`${JSON.stringify({
      ...result,
      reason: "Request was aborted"
    })}`);
    abortError.name = "AbortError";
    throw abortError;
  } else if (result.state === WaiterState.TIMEOUT) {
    const timeoutError = new Error(`${JSON.stringify({
      ...result,
      reason: "Waiter has timed out"
    })}`);
    timeoutError.name = "TimeoutError";
    throw timeoutError;
  } else if (result.state !== WaiterState.SUCCESS) {
    throw new Error(`${JSON.stringify({ result })}`);
  }
  return result;
};

// node_modules/@smithy/util-waiter/dist-es/poller.js
var exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
  if (attempt > attemptCeiling)
    return maxDelay;
  const delay = minDelay * 2 ** (attempt - 1);
  return randomInRange(minDelay, delay);
};
var randomInRange = (min, max) => min + Math.random() * (max - min);
var runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {
  var _a;
  const { state, reason } = await acceptorChecks(client, input);
  if (state !== WaiterState.RETRY) {
    return { state, reason };
  }
  let currentAttempt = 1;
  const waitUntil = Date.now() + maxWaitTime * 1e3;
  const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
  while (true) {
    if (((_a = abortController == null ? void 0 : abortController.signal) == null ? void 0 : _a.aborted) || (abortSignal == null ? void 0 : abortSignal.aborted)) {
      return { state: WaiterState.ABORTED };
    }
    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
    if (Date.now() + delay * 1e3 > waitUntil) {
      return { state: WaiterState.TIMEOUT };
    }
    await sleep(delay);
    const { state: state2, reason: reason2 } = await acceptorChecks(client, input);
    if (state2 !== WaiterState.RETRY) {
      return { state: state2, reason: reason2 };
    }
    currentAttempt += 1;
  }
};

// node_modules/@smithy/util-waiter/dist-es/utils/validate.js
var validateWaiterOptions = (options) => {
  if (options.maxWaitTime < 1) {
    throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
  } else if (options.minDelay < 1) {
    throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
  } else if (options.maxDelay < 1) {
    throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
  } else if (options.maxWaitTime <= options.minDelay) {
    throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
  } else if (options.maxDelay < options.minDelay) {
    throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
  }
};

// node_modules/@smithy/util-waiter/dist-es/createWaiter.js
var abortTimeout = async (abortSignal) => {
  return new Promise((resolve) => {
    abortSignal.onabort = () => resolve({ state: WaiterState.ABORTED });
  });
};
var createWaiter = async (options, input, acceptorChecks) => {
  const params = {
    ...waiterServiceDefaults,
    ...options
  };
  validateWaiterOptions(params);
  const exitConditions = [runPolling(params, input, acceptorChecks)];
  if (options.abortController) {
    exitConditions.push(abortTimeout(options.abortController.signal));
  }
  if (options.abortSignal) {
    exitConditions.push(abortTimeout(options.abortSignal));
  }
  return Promise.race(exitConditions);
};

// node_modules/@aws-sdk/client-rekognition/dist-es/waiters/waitForProjectVersionRunning.js
var checkState = async (client, input) => {
  let reason;
  try {
    const result = await client.send(new DescribeProjectVersionsCommand(input));
    reason = result;
    try {
      const returnComparator = () => {
        const flat_1 = [].concat(...result.ProjectVersionDescriptions);
        const projection_3 = flat_1.map((element_2) => {
          return element_2.Status;
        });
        return projection_3;
      };
      let allStringEq_5 = returnComparator().length > 0;
      for (const element_4 of returnComparator()) {
        allStringEq_5 = allStringEq_5 && element_4 == "RUNNING";
      }
      if (allStringEq_5) {
        return { state: WaiterState.SUCCESS, reason };
      }
    } catch (e2) {
    }
    try {
      const returnComparator = () => {
        const flat_1 = [].concat(...result.ProjectVersionDescriptions);
        const projection_3 = flat_1.map((element_2) => {
          return element_2.Status;
        });
        return projection_3;
      };
      for (const anyStringEq_4 of returnComparator()) {
        if (anyStringEq_4 == "FAILED") {
          return { state: WaiterState.FAILURE, reason };
        }
      }
    } catch (e2) {
    }
  } catch (exception) {
    reason = exception;
  }
  return { state: WaiterState.RETRY, reason };
};
var waitForProjectVersionRunning = async (params, input) => {
  const serviceDefaults = { minDelay: 30, maxDelay: 120 };
  return createWaiter({ ...serviceDefaults, ...params }, input, checkState);
};
var waitUntilProjectVersionRunning = async (params, input) => {
  const serviceDefaults = { minDelay: 30, maxDelay: 120 };
  const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState);
  return checkExceptions(result);
};

// node_modules/@aws-sdk/client-rekognition/dist-es/waiters/waitForProjectVersionTrainingCompleted.js
var checkState2 = async (client, input) => {
  let reason;
  try {
    const result = await client.send(new DescribeProjectVersionsCommand(input));
    reason = result;
    try {
      const returnComparator = () => {
        const flat_1 = [].concat(...result.ProjectVersionDescriptions);
        const projection_3 = flat_1.map((element_2) => {
          return element_2.Status;
        });
        return projection_3;
      };
      let allStringEq_5 = returnComparator().length > 0;
      for (const element_4 of returnComparator()) {
        allStringEq_5 = allStringEq_5 && element_4 == "TRAINING_COMPLETED";
      }
      if (allStringEq_5) {
        return { state: WaiterState.SUCCESS, reason };
      }
    } catch (e2) {
    }
    try {
      const returnComparator = () => {
        const flat_1 = [].concat(...result.ProjectVersionDescriptions);
        const projection_3 = flat_1.map((element_2) => {
          return element_2.Status;
        });
        return projection_3;
      };
      for (const anyStringEq_4 of returnComparator()) {
        if (anyStringEq_4 == "TRAINING_FAILED") {
          return { state: WaiterState.FAILURE, reason };
        }
      }
    } catch (e2) {
    }
  } catch (exception) {
    reason = exception;
  }
  return { state: WaiterState.RETRY, reason };
};
var waitForProjectVersionTrainingCompleted = async (params, input) => {
  const serviceDefaults = { minDelay: 120, maxDelay: 120 };
  return createWaiter({ ...serviceDefaults, ...params }, input, checkState2);
};
var waitUntilProjectVersionTrainingCompleted = async (params, input) => {
  const serviceDefaults = { minDelay: 120, maxDelay: 120 };
  const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState2);
  return checkExceptions(result);
};
export {
  Command as $Command,
  AccessDeniedException,
  AssociateFacesCommand,
  Attribute,
  AuditImageFilterSensitiveLog,
  BodyPart,
  CelebrityRecognitionSortBy,
  CompareFacesCommand,
  ConflictException,
  ContentClassifier,
  ContentModerationAggregateBy,
  ContentModerationSortBy,
  CopyProjectVersionCommand,
  CreateCollectionCommand,
  CreateDatasetCommand,
  CreateFaceLivenessSessionCommand,
  CreateProjectCommand,
  CreateProjectVersionCommand,
  CreateStreamProcessorCommand,
  CreateUserCommand,
  CustomizationFeature,
  DatasetStatus,
  DatasetStatusMessageCode,
  DatasetType,
  DeleteCollectionCommand,
  DeleteDatasetCommand,
  DeleteFacesCommand,
  DeleteProjectCommand,
  DeleteProjectPolicyCommand,
  DeleteProjectVersionCommand,
  DeleteStreamProcessorCommand,
  DeleteUserCommand,
  DescribeCollectionCommand,
  DescribeDatasetCommand,
  DescribeProjectVersionsCommand,
  DescribeProjectsCommand,
  DescribeStreamProcessorCommand,
  DetectCustomLabelsCommand,
  DetectFacesCommand,
  DetectLabelsCommand,
  DetectLabelsFeatureName,
  DetectModerationLabelsCommand,
  DetectProtectiveEquipmentCommand,
  DetectTextCommand,
  DisassociateFacesCommand,
  DistributeDatasetEntriesCommand,
  EmotionName,
  FaceAttributes,
  FaceSearchSortBy,
  GenderType,
  GetCelebrityInfoCommand,
  GetCelebrityRecognitionCommand,
  GetContentModerationCommand,
  GetFaceDetectionCommand,
  GetFaceLivenessSessionResultsCommand,
  GetFaceLivenessSessionResultsResponseFilterSensitiveLog,
  GetFaceSearchCommand,
  GetLabelDetectionCommand,
  GetMediaAnalysisJobCommand,
  GetPersonTrackingCommand,
  GetSegmentDetectionCommand,
  GetTextDetectionCommand,
  HumanLoopQuotaExceededException,
  IdempotentParameterMismatchException,
  ImageTooLargeException,
  IndexFacesCommand,
  InternalServerError,
  InvalidImageFormatException,
  InvalidManifestException,
  InvalidPaginationTokenException,
  InvalidParameterException,
  InvalidPolicyRevisionIdException,
  InvalidS3ObjectException,
  KnownGenderType,
  LabelDetectionAggregateBy,
  LabelDetectionFeatureName,
  LabelDetectionSortBy,
  LandmarkType,
  LimitExceededException,
  ListCollectionsCommand,
  ListDatasetEntriesCommand,
  ListDatasetLabelsCommand,
  ListFacesCommand,
  ListMediaAnalysisJobsCommand,
  ListProjectPoliciesCommand,
  ListStreamProcessorsCommand,
  ListTagsForResourceCommand,
  ListUsersCommand,
  LivenessSessionStatus,
  MalformedPolicyDocumentException,
  MediaAnalysisJobFailureCode,
  MediaAnalysisJobStatus,
  OrientationCorrection,
  PersonTrackingSortBy,
  ProjectAutoUpdate,
  ProjectStatus,
  ProjectVersionStatus,
  ProtectiveEquipmentType,
  ProvisionedThroughputExceededException,
  PutProjectPolicyCommand,
  QualityFilter,
  Reason,
  RecognizeCelebritiesCommand,
  Rekognition,
  RekognitionClient,
  RekognitionServiceException,
  ResourceAlreadyExistsException,
  ResourceInUseException,
  ResourceNotFoundException,
  ResourceNotReadyException,
  SearchFacesByImageCommand,
  SearchFacesCommand,
  SearchUsersByImageCommand,
  SearchUsersCommand,
  SegmentType,
  ServiceQuotaExceededException,
  SessionNotFoundException,
  StartCelebrityRecognitionCommand,
  StartContentModerationCommand,
  StartFaceDetectionCommand,
  StartFaceSearchCommand,
  StartLabelDetectionCommand,
  StartMediaAnalysisJobCommand,
  StartPersonTrackingCommand,
  StartProjectVersionCommand,
  StartSegmentDetectionCommand,
  StartStreamProcessorCommand,
  StartTextDetectionCommand,
  StopProjectVersionCommand,
  StopStreamProcessorCommand,
  StreamProcessorParameterToDelete,
  StreamProcessorStatus,
  TagResourceCommand,
  TechnicalCueType,
  TextTypes,
  ThrottlingException,
  UnsearchedFaceReason,
  UnsuccessfulFaceAssociationReason,
  UnsuccessfulFaceDeletionReason,
  UnsuccessfulFaceDisassociationReason,
  UntagResourceCommand,
  UpdateDatasetEntriesCommand,
  UpdateStreamProcessorCommand,
  UserStatus,
  VideoColorRange,
  VideoJobStatus,
  VideoTooLargeException,
  Client as __Client,
  paginateDescribeProjectVersions,
  paginateDescribeProjects,
  paginateGetCelebrityRecognition,
  paginateGetContentModeration,
  paginateGetFaceDetection,
  paginateGetFaceSearch,
  paginateGetLabelDetection,
  paginateGetPersonTracking,
  paginateGetSegmentDetection,
  paginateGetTextDetection,
  paginateListCollections,
  paginateListDatasetEntries,
  paginateListDatasetLabels,
  paginateListFaces,
  paginateListMediaAnalysisJobs,
  paginateListProjectPolicies,
  paginateListStreamProcessors,
  paginateListUsers,
  waitForProjectVersionRunning,
  waitForProjectVersionTrainingCompleted,
  waitUntilProjectVersionRunning,
  waitUntilProjectVersionTrainingCompleted
};
//# sourceMappingURL=@aws-sdk_client-rekognition.js.map
