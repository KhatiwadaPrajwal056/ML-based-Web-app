"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_UpdateAdapterCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_StartLendingAnalysisCommand = exports.de_StartExpenseAnalysisCommand = exports.de_StartDocumentTextDetectionCommand = exports.de_StartDocumentAnalysisCommand = exports.de_ListTagsForResourceCommand = exports.de_ListAdapterVersionsCommand = exports.de_ListAdaptersCommand = exports.de_GetLendingAnalysisSummaryCommand = exports.de_GetLendingAnalysisCommand = exports.de_GetExpenseAnalysisCommand = exports.de_GetDocumentTextDetectionCommand = exports.de_GetDocumentAnalysisCommand = exports.de_GetAdapterVersionCommand = exports.de_GetAdapterCommand = exports.de_DetectDocumentTextCommand = exports.de_DeleteAdapterVersionCommand = exports.de_DeleteAdapterCommand = exports.de_CreateAdapterVersionCommand = exports.de_CreateAdapterCommand = exports.de_AnalyzeIDCommand = exports.de_AnalyzeExpenseCommand = exports.de_AnalyzeDocumentCommand = exports.se_UpdateAdapterCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_StartLendingAnalysisCommand = exports.se_StartExpenseAnalysisCommand = exports.se_StartDocumentTextDetectionCommand = exports.se_StartDocumentAnalysisCommand = exports.se_ListTagsForResourceCommand = exports.se_ListAdapterVersionsCommand = exports.se_ListAdaptersCommand = exports.se_GetLendingAnalysisSummaryCommand = exports.se_GetLendingAnalysisCommand = exports.se_GetExpenseAnalysisCommand = exports.se_GetDocumentTextDetectionCommand = exports.se_GetDocumentAnalysisCommand = exports.se_GetAdapterVersionCommand = exports.se_GetAdapterCommand = exports.se_DetectDocumentTextCommand = exports.se_DeleteAdapterVersionCommand = exports.se_DeleteAdapterCommand = exports.se_CreateAdapterVersionCommand = exports.se_CreateAdapterCommand = exports.se_AnalyzeIDCommand = exports.se_AnalyzeExpenseCommand = exports.se_AnalyzeDocumentCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const uuid_1 = require("uuid");
const models_0_1 = require("../models/models_0");
const TextractServiceException_1 = require("../models/TextractServiceException");
const se_AnalyzeDocumentCommand = async (input, context) => {
    const headers = sharedHeaders("AnalyzeDocument");
    let body;
    body = JSON.stringify(se_AnalyzeDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AnalyzeDocumentCommand = se_AnalyzeDocumentCommand;
const se_AnalyzeExpenseCommand = async (input, context) => {
    const headers = sharedHeaders("AnalyzeExpense");
    let body;
    body = JSON.stringify(se_AnalyzeExpenseRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AnalyzeExpenseCommand = se_AnalyzeExpenseCommand;
const se_AnalyzeIDCommand = async (input, context) => {
    const headers = sharedHeaders("AnalyzeID");
    let body;
    body = JSON.stringify(se_AnalyzeIDRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AnalyzeIDCommand = se_AnalyzeIDCommand;
const se_CreateAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("CreateAdapter");
    let body;
    body = JSON.stringify(se_CreateAdapterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateAdapterCommand = se_CreateAdapterCommand;
const se_CreateAdapterVersionCommand = async (input, context) => {
    const headers = sharedHeaders("CreateAdapterVersion");
    let body;
    body = JSON.stringify(se_CreateAdapterVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateAdapterVersionCommand = se_CreateAdapterVersionCommand;
const se_DeleteAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteAdapter");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteAdapterCommand = se_DeleteAdapterCommand;
const se_DeleteAdapterVersionCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteAdapterVersion");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteAdapterVersionCommand = se_DeleteAdapterVersionCommand;
const se_DetectDocumentTextCommand = async (input, context) => {
    const headers = sharedHeaders("DetectDocumentText");
    let body;
    body = JSON.stringify(se_DetectDocumentTextRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DetectDocumentTextCommand = se_DetectDocumentTextCommand;
const se_GetAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("GetAdapter");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAdapterCommand = se_GetAdapterCommand;
const se_GetAdapterVersionCommand = async (input, context) => {
    const headers = sharedHeaders("GetAdapterVersion");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAdapterVersionCommand = se_GetAdapterVersionCommand;
const se_GetDocumentAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("GetDocumentAnalysis");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDocumentAnalysisCommand = se_GetDocumentAnalysisCommand;
const se_GetDocumentTextDetectionCommand = async (input, context) => {
    const headers = sharedHeaders("GetDocumentTextDetection");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDocumentTextDetectionCommand = se_GetDocumentTextDetectionCommand;
const se_GetExpenseAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("GetExpenseAnalysis");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetExpenseAnalysisCommand = se_GetExpenseAnalysisCommand;
const se_GetLendingAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("GetLendingAnalysis");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetLendingAnalysisCommand = se_GetLendingAnalysisCommand;
const se_GetLendingAnalysisSummaryCommand = async (input, context) => {
    const headers = sharedHeaders("GetLendingAnalysisSummary");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetLendingAnalysisSummaryCommand = se_GetLendingAnalysisSummaryCommand;
const se_ListAdaptersCommand = async (input, context) => {
    const headers = sharedHeaders("ListAdapters");
    let body;
    body = JSON.stringify(se_ListAdaptersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAdaptersCommand = se_ListAdaptersCommand;
const se_ListAdapterVersionsCommand = async (input, context) => {
    const headers = sharedHeaders("ListAdapterVersions");
    let body;
    body = JSON.stringify(se_ListAdapterVersionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAdapterVersionsCommand = se_ListAdapterVersionsCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_StartDocumentAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("StartDocumentAnalysis");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StartDocumentAnalysisCommand = se_StartDocumentAnalysisCommand;
const se_StartDocumentTextDetectionCommand = async (input, context) => {
    const headers = sharedHeaders("StartDocumentTextDetection");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StartDocumentTextDetectionCommand = se_StartDocumentTextDetectionCommand;
const se_StartExpenseAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("StartExpenseAnalysis");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StartExpenseAnalysisCommand = se_StartExpenseAnalysisCommand;
const se_StartLendingAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("StartLendingAnalysis");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StartLendingAnalysisCommand = se_StartLendingAnalysisCommand;
const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateAdapter");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateAdapterCommand = se_UpdateAdapterCommand;
const de_AnalyzeDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AnalyzeDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AnalyzeDocumentResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AnalyzeDocumentCommand = de_AnalyzeDocumentCommand;
const de_AnalyzeDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "HumanLoopQuotaExceededException":
        case "com.amazonaws.textract#HumanLoopQuotaExceededException":
            throw await de_HumanLoopQuotaExceededExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AnalyzeExpenseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AnalyzeExpenseCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AnalyzeExpenseResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AnalyzeExpenseCommand = de_AnalyzeExpenseCommand;
const de_AnalyzeExpenseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AnalyzeIDCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AnalyzeIDCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AnalyzeIDResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AnalyzeIDCommand = de_AnalyzeIDCommand;
const de_AnalyzeIDCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateAdapterCommand = de_CreateAdapterCommand;
const de_CreateAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.textract#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAdapterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAdapterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateAdapterVersionCommand = de_CreateAdapterVersionCommand;
const de_CreateAdapterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.textract#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteAdapterCommand = de_DeleteAdapterCommand;
const de_DeleteAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAdapterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAdapterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteAdapterVersionCommand = de_DeleteAdapterVersionCommand;
const de_DeleteAdapterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DetectDocumentTextCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetectDocumentTextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetectDocumentTextResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DetectDocumentTextCommand = de_DetectDocumentTextCommand;
const de_DetectDocumentTextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAdapterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAdapterCommand = de_GetAdapterCommand;
const de_GetAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAdapterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAdapterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAdapterVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAdapterVersionCommand = de_GetAdapterVersionCommand;
const de_GetAdapterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDocumentAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDocumentAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDocumentAnalysisResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDocumentAnalysisCommand = de_GetDocumentAnalysisCommand;
const de_GetDocumentAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDocumentTextDetectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDocumentTextDetectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDocumentTextDetectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDocumentTextDetectionCommand = de_GetDocumentTextDetectionCommand;
const de_GetDocumentTextDetectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetExpenseAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetExpenseAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetExpenseAnalysisResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetExpenseAnalysisCommand = de_GetExpenseAnalysisCommand;
const de_GetExpenseAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetLendingAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetLendingAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetLendingAnalysisResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetLendingAnalysisCommand = de_GetLendingAnalysisCommand;
const de_GetLendingAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetLendingAnalysisSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetLendingAnalysisSummaryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetLendingAnalysisSummaryCommand = de_GetLendingAnalysisSummaryCommand;
const de_GetLendingAnalysisSummaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAdaptersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAdaptersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAdaptersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAdaptersCommand = de_ListAdaptersCommand;
const de_ListAdaptersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAdapterVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAdapterVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAdapterVersionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAdapterVersionsCommand = de_ListAdapterVersionsCommand;
const de_ListAdapterVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartDocumentAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartDocumentAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_StartDocumentAnalysisCommand = de_StartDocumentAnalysisCommand;
const de_StartDocumentAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartDocumentTextDetectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartDocumentTextDetectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_StartDocumentTextDetectionCommand = de_StartDocumentTextDetectionCommand;
const de_StartDocumentTextDetectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartExpenseAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartExpenseAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_StartExpenseAnalysisCommand = de_StartExpenseAnalysisCommand;
const de_StartExpenseAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartLendingAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartLendingAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_StartLendingAnalysisCommand = de_StartLendingAnalysisCommand;
const de_StartLendingAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.textract#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateAdapterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateAdapterCommand = de_UpdateAdapterCommand;
const de_UpdateAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BadDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BadDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DocumentTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DocumentTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_HumanLoopQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.HumanLoopQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IdempotentParameterMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IdempotentParameterMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InternalServerErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InternalServerError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidJobIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidJobIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidKMSKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidKMSKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidS3ObjectExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidS3ObjectException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ProvisionedThroughputExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_AnalyzeDocumentRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AdaptersConfig: smithy_client_1._json,
        Document: (_) => se_Document(_, context),
        FeatureTypes: smithy_client_1._json,
        HumanLoopConfig: smithy_client_1._json,
        QueriesConfig: smithy_client_1._json,
    });
};
const se_AnalyzeExpenseRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Document: (_) => se_Document(_, context),
    });
};
const se_AnalyzeIDRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DocumentPages: (_) => se_DocumentPages(_, context),
    });
};
const se_CreateAdapterRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AdapterName: [],
        AutoUpdate: [],
        ClientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        Description: [],
        FeatureTypes: smithy_client_1._json,
        Tags: smithy_client_1._json,
    });
};
const se_CreateAdapterVersionRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AdapterId: [],
        ClientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        DatasetConfig: smithy_client_1._json,
        KMSKeyId: [],
        OutputConfig: smithy_client_1._json,
        Tags: smithy_client_1._json,
    });
};
const se_DetectDocumentTextRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Document: (_) => se_Document(_, context),
    });
};
const se_Document = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Bytes: context.base64Encoder,
        S3Object: smithy_client_1._json,
    });
};
const se_DocumentPages = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Document(entry, context);
    });
};
const se_ListAdaptersRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AfterCreationTime: (_) => Math.round(_.getTime() / 1000),
        BeforeCreationTime: (_) => Math.round(_.getTime() / 1000),
        MaxResults: [],
        NextToken: [],
    });
};
const se_ListAdapterVersionsRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AdapterId: [],
        AfterCreationTime: (_) => Math.round(_.getTime() / 1000),
        BeforeCreationTime: (_) => Math.round(_.getTime() / 1000),
        MaxResults: [],
        NextToken: [],
    });
};
const de_AdapterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdapterOverview(entry, context);
    });
    return retVal;
};
const de_AdapterOverview = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterId: smithy_client_1.expectString,
        AdapterName: smithy_client_1.expectString,
        CreationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        FeatureTypes: smithy_client_1._json,
    });
};
const de_AdapterVersionEvaluationMetric = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterVersion: (_) => de_EvaluationMetric(_, context),
        Baseline: (_) => de_EvaluationMetric(_, context),
        FeatureType: smithy_client_1.expectString,
    });
};
const de_AdapterVersionEvaluationMetrics = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdapterVersionEvaluationMetric(entry, context);
    });
    return retVal;
};
const de_AdapterVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdapterVersionOverview(entry, context);
    });
    return retVal;
};
const de_AdapterVersionOverview = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterId: smithy_client_1.expectString,
        AdapterVersion: smithy_client_1.expectString,
        CreationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        FeatureTypes: smithy_client_1._json,
        Status: smithy_client_1.expectString,
        StatusMessage: smithy_client_1.expectString,
    });
};
const de_AnalyzeDocumentResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AnalyzeDocumentModelVersion: smithy_client_1.expectString,
        Blocks: (_) => de_BlockList(_, context),
        DocumentMetadata: smithy_client_1._json,
        HumanLoopActivationOutput: (_) => de_HumanLoopActivationOutput(_, context),
    });
};
const de_AnalyzeExpenseResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DocumentMetadata: smithy_client_1._json,
        ExpenseDocuments: (_) => de_ExpenseDocumentList(_, context),
    });
};
const de_AnalyzeIDDetections = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseFloat32,
        NormalizedValue: smithy_client_1._json,
        Text: smithy_client_1.expectString,
    });
};
const de_AnalyzeIDResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AnalyzeIDModelVersion: smithy_client_1.expectString,
        DocumentMetadata: smithy_client_1._json,
        IdentityDocuments: (_) => de_IdentityDocumentList(_, context),
    });
};
const de_Block = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BlockType: smithy_client_1.expectString,
        ColumnIndex: smithy_client_1.expectInt32,
        ColumnSpan: smithy_client_1.expectInt32,
        Confidence: smithy_client_1.limitedParseFloat32,
        EntityTypes: smithy_client_1._json,
        Geometry: (_) => de_Geometry(_, context),
        Id: smithy_client_1.expectString,
        Page: smithy_client_1.expectInt32,
        Query: smithy_client_1._json,
        Relationships: smithy_client_1._json,
        RowIndex: smithy_client_1.expectInt32,
        RowSpan: smithy_client_1.expectInt32,
        SelectionStatus: smithy_client_1.expectString,
        Text: smithy_client_1.expectString,
        TextType: smithy_client_1.expectString,
    });
};
const de_BlockList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Block(entry, context);
    });
    return retVal;
};
const de_BoundingBox = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Height: smithy_client_1.limitedParseFloat32,
        Left: smithy_client_1.limitedParseFloat32,
        Top: smithy_client_1.limitedParseFloat32,
        Width: smithy_client_1.limitedParseFloat32,
    });
};
const de_DetectDocumentTextResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Blocks: (_) => de_BlockList(_, context),
        DetectDocumentTextModelVersion: smithy_client_1.expectString,
        DocumentMetadata: smithy_client_1._json,
    });
};
const de_EvaluationMetric = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        F1Score: smithy_client_1.limitedParseFloat32,
        Precision: smithy_client_1.limitedParseFloat32,
        Recall: smithy_client_1.limitedParseFloat32,
    });
};
const de_ExpenseCurrency = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Code: smithy_client_1.expectString,
        Confidence: smithy_client_1.limitedParseFloat32,
    });
};
const de_ExpenseDetection = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseFloat32,
        Geometry: (_) => de_Geometry(_, context),
        Text: smithy_client_1.expectString,
    });
};
const de_ExpenseDocument = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Blocks: (_) => de_BlockList(_, context),
        ExpenseIndex: smithy_client_1.expectInt32,
        LineItemGroups: (_) => de_LineItemGroupList(_, context),
        SummaryFields: (_) => de_ExpenseFieldList(_, context),
    });
};
const de_ExpenseDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExpenseDocument(entry, context);
    });
    return retVal;
};
const de_ExpenseField = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Currency: (_) => de_ExpenseCurrency(_, context),
        GroupProperties: smithy_client_1._json,
        LabelDetection: (_) => de_ExpenseDetection(_, context),
        PageNumber: smithy_client_1.expectInt32,
        Type: (_) => de_ExpenseType(_, context),
        ValueDetection: (_) => de_ExpenseDetection(_, context),
    });
};
const de_ExpenseFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExpenseField(entry, context);
    });
    return retVal;
};
const de_ExpenseType = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseFloat32,
        Text: smithy_client_1.expectString,
    });
};
const de_Extraction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ExpenseDocument: (_) => de_ExpenseDocument(_, context),
        IdentityDocument: (_) => de_IdentityDocument(_, context),
        LendingDocument: (_) => de_LendingDocument(_, context),
    });
};
const de_ExtractionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Extraction(entry, context);
    });
    return retVal;
};
const de_Geometry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BoundingBox: (_) => de_BoundingBox(_, context),
        Polygon: (_) => de_Polygon(_, context),
    });
};
const de_GetAdapterResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterId: smithy_client_1.expectString,
        AdapterName: smithy_client_1.expectString,
        AutoUpdate: smithy_client_1.expectString,
        CreationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Description: smithy_client_1.expectString,
        FeatureTypes: smithy_client_1._json,
        Tags: smithy_client_1._json,
    });
};
const de_GetAdapterVersionResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterId: smithy_client_1.expectString,
        AdapterVersion: smithy_client_1.expectString,
        CreationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        DatasetConfig: smithy_client_1._json,
        EvaluationMetrics: (_) => de_AdapterVersionEvaluationMetrics(_, context),
        FeatureTypes: smithy_client_1._json,
        KMSKeyId: smithy_client_1.expectString,
        OutputConfig: smithy_client_1._json,
        Status: smithy_client_1.expectString,
        StatusMessage: smithy_client_1.expectString,
        Tags: smithy_client_1._json,
    });
};
const de_GetDocumentAnalysisResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AnalyzeDocumentModelVersion: smithy_client_1.expectString,
        Blocks: (_) => de_BlockList(_, context),
        DocumentMetadata: smithy_client_1._json,
        JobStatus: smithy_client_1.expectString,
        NextToken: smithy_client_1.expectString,
        StatusMessage: smithy_client_1.expectString,
        Warnings: smithy_client_1._json,
    });
};
const de_GetDocumentTextDetectionResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Blocks: (_) => de_BlockList(_, context),
        DetectDocumentTextModelVersion: smithy_client_1.expectString,
        DocumentMetadata: smithy_client_1._json,
        JobStatus: smithy_client_1.expectString,
        NextToken: smithy_client_1.expectString,
        StatusMessage: smithy_client_1.expectString,
        Warnings: smithy_client_1._json,
    });
};
const de_GetExpenseAnalysisResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AnalyzeExpenseModelVersion: smithy_client_1.expectString,
        DocumentMetadata: smithy_client_1._json,
        ExpenseDocuments: (_) => de_ExpenseDocumentList(_, context),
        JobStatus: smithy_client_1.expectString,
        NextToken: smithy_client_1.expectString,
        StatusMessage: smithy_client_1.expectString,
        Warnings: smithy_client_1._json,
    });
};
const de_GetLendingAnalysisResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AnalyzeLendingModelVersion: smithy_client_1.expectString,
        DocumentMetadata: smithy_client_1._json,
        JobStatus: smithy_client_1.expectString,
        NextToken: smithy_client_1.expectString,
        Results: (_) => de_LendingResultList(_, context),
        StatusMessage: smithy_client_1.expectString,
        Warnings: smithy_client_1._json,
    });
};
const de_HumanLoopActivationOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        HumanLoopActivationConditionsEvaluationResults: (_) => new smithy_client_1.LazyJsonString(_),
        HumanLoopActivationReasons: smithy_client_1._json,
        HumanLoopArn: smithy_client_1.expectString,
    });
};
const de_IdentityDocument = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Blocks: (_) => de_BlockList(_, context),
        DocumentIndex: smithy_client_1.expectInt32,
        IdentityDocumentFields: (_) => de_IdentityDocumentFieldList(_, context),
    });
};
const de_IdentityDocumentField = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Type: (_) => de_AnalyzeIDDetections(_, context),
        ValueDetection: (_) => de_AnalyzeIDDetections(_, context),
    });
};
const de_IdentityDocumentFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IdentityDocumentField(entry, context);
    });
    return retVal;
};
const de_IdentityDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IdentityDocument(entry, context);
    });
    return retVal;
};
const de_LendingDetection = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseFloat32,
        Geometry: (_) => de_Geometry(_, context),
        SelectionStatus: smithy_client_1.expectString,
        Text: smithy_client_1.expectString,
    });
};
const de_LendingDetectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LendingDetection(entry, context);
    });
    return retVal;
};
const de_LendingDocument = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LendingFields: (_) => de_LendingFieldList(_, context),
        SignatureDetections: (_) => de_SignatureDetectionList(_, context),
    });
};
const de_LendingField = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KeyDetection: (_) => de_LendingDetection(_, context),
        Type: smithy_client_1.expectString,
        ValueDetections: (_) => de_LendingDetectionList(_, context),
    });
};
const de_LendingFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LendingField(entry, context);
    });
    return retVal;
};
const de_LendingResult = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Extractions: (_) => de_ExtractionList(_, context),
        Page: smithy_client_1.expectInt32,
        PageClassification: (_) => de_PageClassification(_, context),
    });
};
const de_LendingResultList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LendingResult(entry, context);
    });
    return retVal;
};
const de_LineItemFields = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LineItemExpenseFields: (_) => de_ExpenseFieldList(_, context),
    });
};
const de_LineItemGroup = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LineItemGroupIndex: smithy_client_1.expectInt32,
        LineItems: (_) => de_LineItemList(_, context),
    });
};
const de_LineItemGroupList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LineItemGroup(entry, context);
    });
    return retVal;
};
const de_LineItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LineItemFields(entry, context);
    });
    return retVal;
};
const de_ListAdaptersResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Adapters: (_) => de_AdapterList(_, context),
        NextToken: smithy_client_1.expectString,
    });
};
const de_ListAdapterVersionsResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterVersions: (_) => de_AdapterVersionList(_, context),
        NextToken: smithy_client_1.expectString,
    });
};
const de_PageClassification = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        PageNumber: (_) => de_PredictionList(_, context),
        PageType: (_) => de_PredictionList(_, context),
    });
};
const de_Point = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        X: smithy_client_1.limitedParseFloat32,
        Y: smithy_client_1.limitedParseFloat32,
    });
};
const de_Polygon = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Point(entry, context);
    });
    return retVal;
};
const de_Prediction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseFloat32,
        Value: smithy_client_1.expectString,
    });
};
const de_PredictionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Prediction(entry, context);
    });
    return retVal;
};
const de_SignatureDetection = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseFloat32,
        Geometry: (_) => de_Geometry(_, context),
    });
};
const de_SignatureDetectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SignatureDetection(entry, context);
    });
    return retVal;
};
const de_UpdateAdapterResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AdapterId: smithy_client_1.expectString,
        AdapterName: smithy_client_1.expectString,
        AutoUpdate: smithy_client_1.expectString,
        CreationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Description: smithy_client_1.expectString,
        FeatureTypes: smithy_client_1._json,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(TextractServiceException_1.TextractServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `Textract.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
