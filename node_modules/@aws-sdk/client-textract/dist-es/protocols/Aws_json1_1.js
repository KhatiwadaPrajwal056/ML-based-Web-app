import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, LazyJsonString as __LazyJsonString, limitedParseFloat32 as __limitedParseFloat32, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { AccessDeniedException, BadDocumentException, ConflictException, DocumentTooLargeException, HumanLoopQuotaExceededException, IdempotentParameterMismatchException, InternalServerError, InvalidJobIdException, InvalidKMSKeyException, InvalidParameterException, InvalidS3ObjectException, LimitExceededException, ProvisionedThroughputExceededException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, UnsupportedDocumentException, ValidationException, } from "../models/models_0";
import { TextractServiceException as __BaseException } from "../models/TextractServiceException";
export const se_AnalyzeDocumentCommand = async (input, context) => {
    const headers = sharedHeaders("AnalyzeDocument");
    let body;
    body = JSON.stringify(se_AnalyzeDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AnalyzeExpenseCommand = async (input, context) => {
    const headers = sharedHeaders("AnalyzeExpense");
    let body;
    body = JSON.stringify(se_AnalyzeExpenseRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AnalyzeIDCommand = async (input, context) => {
    const headers = sharedHeaders("AnalyzeID");
    let body;
    body = JSON.stringify(se_AnalyzeIDRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("CreateAdapter");
    let body;
    body = JSON.stringify(se_CreateAdapterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAdapterVersionCommand = async (input, context) => {
    const headers = sharedHeaders("CreateAdapterVersion");
    let body;
    body = JSON.stringify(se_CreateAdapterVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteAdapter");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAdapterVersionCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteAdapterVersion");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetectDocumentTextCommand = async (input, context) => {
    const headers = sharedHeaders("DetectDocumentText");
    let body;
    body = JSON.stringify(se_DetectDocumentTextRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("GetAdapter");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAdapterVersionCommand = async (input, context) => {
    const headers = sharedHeaders("GetAdapterVersion");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDocumentAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("GetDocumentAnalysis");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDocumentTextDetectionCommand = async (input, context) => {
    const headers = sharedHeaders("GetDocumentTextDetection");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetExpenseAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("GetExpenseAnalysis");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetLendingAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("GetLendingAnalysis");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetLendingAnalysisSummaryCommand = async (input, context) => {
    const headers = sharedHeaders("GetLendingAnalysisSummary");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAdaptersCommand = async (input, context) => {
    const headers = sharedHeaders("ListAdapters");
    let body;
    body = JSON.stringify(se_ListAdaptersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAdapterVersionsCommand = async (input, context) => {
    const headers = sharedHeaders("ListAdapterVersions");
    let body;
    body = JSON.stringify(se_ListAdapterVersionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartDocumentAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("StartDocumentAnalysis");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartDocumentTextDetectionCommand = async (input, context) => {
    const headers = sharedHeaders("StartDocumentTextDetection");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartExpenseAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("StartExpenseAnalysis");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartLendingAnalysisCommand = async (input, context) => {
    const headers = sharedHeaders("StartLendingAnalysis");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAdapterCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateAdapter");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AnalyzeDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AnalyzeDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AnalyzeDocumentResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AnalyzeDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "HumanLoopQuotaExceededException":
        case "com.amazonaws.textract#HumanLoopQuotaExceededException":
            throw await de_HumanLoopQuotaExceededExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AnalyzeExpenseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AnalyzeExpenseCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AnalyzeExpenseResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AnalyzeExpenseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AnalyzeIDCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AnalyzeIDCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AnalyzeIDResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AnalyzeIDCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.textract#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateAdapterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAdapterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateAdapterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.textract#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAdapterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAdapterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteAdapterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DetectDocumentTextCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetectDocumentTextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetectDocumentTextResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DetectDocumentTextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAdapterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAdapterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAdapterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAdapterVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAdapterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDocumentAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDocumentAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDocumentAnalysisResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetDocumentAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDocumentTextDetectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDocumentTextDetectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDocumentTextDetectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetDocumentTextDetectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetExpenseAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetExpenseAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetExpenseAnalysisResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetExpenseAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetLendingAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetLendingAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetLendingAnalysisResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetLendingAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetLendingAnalysisSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetLendingAnalysisSummaryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetLendingAnalysisSummaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            throw await de_InvalidJobIdExceptionRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAdaptersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAdaptersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAdaptersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAdaptersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAdapterVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAdapterVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAdapterVersionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAdapterVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartDocumentAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartDocumentAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartDocumentAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartDocumentTextDetectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartDocumentTextDetectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartDocumentTextDetectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartExpenseAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartExpenseAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartExpenseAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartLendingAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartLendingAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartLendingAnalysisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            throw await de_BadDocumentExceptionRes(parsedOutput, context);
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            throw await de_DocumentTooLargeExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKMSKeyException":
        case "com.amazonaws.textract#InvalidKMSKeyException":
            throw await de_InvalidKMSKeyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            throw await de_InvalidS3ObjectExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            throw await de_UnsupportedDocumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.textract#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAdapterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAdapterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateAdapterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateAdapterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.textract#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.textract#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.textract#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BadDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BadDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DocumentTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DocumentTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HumanLoopQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new HumanLoopQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IdempotentParameterMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new IdempotentParameterMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServerErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InternalServerError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidJobIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidJobIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidKMSKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidKMSKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidS3ObjectExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidS3ObjectException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ProvisionedThroughputExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UnsupportedDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AnalyzeDocumentRequest = (input, context) => {
    return take(input, {
        AdaptersConfig: _json,
        Document: (_) => se_Document(_, context),
        FeatureTypes: _json,
        HumanLoopConfig: _json,
        QueriesConfig: _json,
    });
};
const se_AnalyzeExpenseRequest = (input, context) => {
    return take(input, {
        Document: (_) => se_Document(_, context),
    });
};
const se_AnalyzeIDRequest = (input, context) => {
    return take(input, {
        DocumentPages: (_) => se_DocumentPages(_, context),
    });
};
const se_CreateAdapterRequest = (input, context) => {
    return take(input, {
        AdapterName: [],
        AutoUpdate: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Description: [],
        FeatureTypes: _json,
        Tags: _json,
    });
};
const se_CreateAdapterVersionRequest = (input, context) => {
    return take(input, {
        AdapterId: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        DatasetConfig: _json,
        KMSKeyId: [],
        OutputConfig: _json,
        Tags: _json,
    });
};
const se_DetectDocumentTextRequest = (input, context) => {
    return take(input, {
        Document: (_) => se_Document(_, context),
    });
};
const se_Document = (input, context) => {
    return take(input, {
        Bytes: context.base64Encoder,
        S3Object: _json,
    });
};
const se_DocumentPages = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Document(entry, context);
    });
};
const se_ListAdaptersRequest = (input, context) => {
    return take(input, {
        AfterCreationTime: (_) => Math.round(_.getTime() / 1000),
        BeforeCreationTime: (_) => Math.round(_.getTime() / 1000),
        MaxResults: [],
        NextToken: [],
    });
};
const se_ListAdapterVersionsRequest = (input, context) => {
    return take(input, {
        AdapterId: [],
        AfterCreationTime: (_) => Math.round(_.getTime() / 1000),
        BeforeCreationTime: (_) => Math.round(_.getTime() / 1000),
        MaxResults: [],
        NextToken: [],
    });
};
const de_AdapterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdapterOverview(entry, context);
    });
    return retVal;
};
const de_AdapterOverview = (output, context) => {
    return take(output, {
        AdapterId: __expectString,
        AdapterName: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        FeatureTypes: _json,
    });
};
const de_AdapterVersionEvaluationMetric = (output, context) => {
    return take(output, {
        AdapterVersion: (_) => de_EvaluationMetric(_, context),
        Baseline: (_) => de_EvaluationMetric(_, context),
        FeatureType: __expectString,
    });
};
const de_AdapterVersionEvaluationMetrics = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdapterVersionEvaluationMetric(entry, context);
    });
    return retVal;
};
const de_AdapterVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdapterVersionOverview(entry, context);
    });
    return retVal;
};
const de_AdapterVersionOverview = (output, context) => {
    return take(output, {
        AdapterId: __expectString,
        AdapterVersion: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        FeatureTypes: _json,
        Status: __expectString,
        StatusMessage: __expectString,
    });
};
const de_AnalyzeDocumentResponse = (output, context) => {
    return take(output, {
        AnalyzeDocumentModelVersion: __expectString,
        Blocks: (_) => de_BlockList(_, context),
        DocumentMetadata: _json,
        HumanLoopActivationOutput: (_) => de_HumanLoopActivationOutput(_, context),
    });
};
const de_AnalyzeExpenseResponse = (output, context) => {
    return take(output, {
        DocumentMetadata: _json,
        ExpenseDocuments: (_) => de_ExpenseDocumentList(_, context),
    });
};
const de_AnalyzeIDDetections = (output, context) => {
    return take(output, {
        Confidence: __limitedParseFloat32,
        NormalizedValue: _json,
        Text: __expectString,
    });
};
const de_AnalyzeIDResponse = (output, context) => {
    return take(output, {
        AnalyzeIDModelVersion: __expectString,
        DocumentMetadata: _json,
        IdentityDocuments: (_) => de_IdentityDocumentList(_, context),
    });
};
const de_Block = (output, context) => {
    return take(output, {
        BlockType: __expectString,
        ColumnIndex: __expectInt32,
        ColumnSpan: __expectInt32,
        Confidence: __limitedParseFloat32,
        EntityTypes: _json,
        Geometry: (_) => de_Geometry(_, context),
        Id: __expectString,
        Page: __expectInt32,
        Query: _json,
        Relationships: _json,
        RowIndex: __expectInt32,
        RowSpan: __expectInt32,
        SelectionStatus: __expectString,
        Text: __expectString,
        TextType: __expectString,
    });
};
const de_BlockList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Block(entry, context);
    });
    return retVal;
};
const de_BoundingBox = (output, context) => {
    return take(output, {
        Height: __limitedParseFloat32,
        Left: __limitedParseFloat32,
        Top: __limitedParseFloat32,
        Width: __limitedParseFloat32,
    });
};
const de_DetectDocumentTextResponse = (output, context) => {
    return take(output, {
        Blocks: (_) => de_BlockList(_, context),
        DetectDocumentTextModelVersion: __expectString,
        DocumentMetadata: _json,
    });
};
const de_EvaluationMetric = (output, context) => {
    return take(output, {
        F1Score: __limitedParseFloat32,
        Precision: __limitedParseFloat32,
        Recall: __limitedParseFloat32,
    });
};
const de_ExpenseCurrency = (output, context) => {
    return take(output, {
        Code: __expectString,
        Confidence: __limitedParseFloat32,
    });
};
const de_ExpenseDetection = (output, context) => {
    return take(output, {
        Confidence: __limitedParseFloat32,
        Geometry: (_) => de_Geometry(_, context),
        Text: __expectString,
    });
};
const de_ExpenseDocument = (output, context) => {
    return take(output, {
        Blocks: (_) => de_BlockList(_, context),
        ExpenseIndex: __expectInt32,
        LineItemGroups: (_) => de_LineItemGroupList(_, context),
        SummaryFields: (_) => de_ExpenseFieldList(_, context),
    });
};
const de_ExpenseDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExpenseDocument(entry, context);
    });
    return retVal;
};
const de_ExpenseField = (output, context) => {
    return take(output, {
        Currency: (_) => de_ExpenseCurrency(_, context),
        GroupProperties: _json,
        LabelDetection: (_) => de_ExpenseDetection(_, context),
        PageNumber: __expectInt32,
        Type: (_) => de_ExpenseType(_, context),
        ValueDetection: (_) => de_ExpenseDetection(_, context),
    });
};
const de_ExpenseFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExpenseField(entry, context);
    });
    return retVal;
};
const de_ExpenseType = (output, context) => {
    return take(output, {
        Confidence: __limitedParseFloat32,
        Text: __expectString,
    });
};
const de_Extraction = (output, context) => {
    return take(output, {
        ExpenseDocument: (_) => de_ExpenseDocument(_, context),
        IdentityDocument: (_) => de_IdentityDocument(_, context),
        LendingDocument: (_) => de_LendingDocument(_, context),
    });
};
const de_ExtractionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Extraction(entry, context);
    });
    return retVal;
};
const de_Geometry = (output, context) => {
    return take(output, {
        BoundingBox: (_) => de_BoundingBox(_, context),
        Polygon: (_) => de_Polygon(_, context),
    });
};
const de_GetAdapterResponse = (output, context) => {
    return take(output, {
        AdapterId: __expectString,
        AdapterName: __expectString,
        AutoUpdate: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        FeatureTypes: _json,
        Tags: _json,
    });
};
const de_GetAdapterVersionResponse = (output, context) => {
    return take(output, {
        AdapterId: __expectString,
        AdapterVersion: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DatasetConfig: _json,
        EvaluationMetrics: (_) => de_AdapterVersionEvaluationMetrics(_, context),
        FeatureTypes: _json,
        KMSKeyId: __expectString,
        OutputConfig: _json,
        Status: __expectString,
        StatusMessage: __expectString,
        Tags: _json,
    });
};
const de_GetDocumentAnalysisResponse = (output, context) => {
    return take(output, {
        AnalyzeDocumentModelVersion: __expectString,
        Blocks: (_) => de_BlockList(_, context),
        DocumentMetadata: _json,
        JobStatus: __expectString,
        NextToken: __expectString,
        StatusMessage: __expectString,
        Warnings: _json,
    });
};
const de_GetDocumentTextDetectionResponse = (output, context) => {
    return take(output, {
        Blocks: (_) => de_BlockList(_, context),
        DetectDocumentTextModelVersion: __expectString,
        DocumentMetadata: _json,
        JobStatus: __expectString,
        NextToken: __expectString,
        StatusMessage: __expectString,
        Warnings: _json,
    });
};
const de_GetExpenseAnalysisResponse = (output, context) => {
    return take(output, {
        AnalyzeExpenseModelVersion: __expectString,
        DocumentMetadata: _json,
        ExpenseDocuments: (_) => de_ExpenseDocumentList(_, context),
        JobStatus: __expectString,
        NextToken: __expectString,
        StatusMessage: __expectString,
        Warnings: _json,
    });
};
const de_GetLendingAnalysisResponse = (output, context) => {
    return take(output, {
        AnalyzeLendingModelVersion: __expectString,
        DocumentMetadata: _json,
        JobStatus: __expectString,
        NextToken: __expectString,
        Results: (_) => de_LendingResultList(_, context),
        StatusMessage: __expectString,
        Warnings: _json,
    });
};
const de_HumanLoopActivationOutput = (output, context) => {
    return take(output, {
        HumanLoopActivationConditionsEvaluationResults: (_) => new __LazyJsonString(_),
        HumanLoopActivationReasons: _json,
        HumanLoopArn: __expectString,
    });
};
const de_IdentityDocument = (output, context) => {
    return take(output, {
        Blocks: (_) => de_BlockList(_, context),
        DocumentIndex: __expectInt32,
        IdentityDocumentFields: (_) => de_IdentityDocumentFieldList(_, context),
    });
};
const de_IdentityDocumentField = (output, context) => {
    return take(output, {
        Type: (_) => de_AnalyzeIDDetections(_, context),
        ValueDetection: (_) => de_AnalyzeIDDetections(_, context),
    });
};
const de_IdentityDocumentFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IdentityDocumentField(entry, context);
    });
    return retVal;
};
const de_IdentityDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IdentityDocument(entry, context);
    });
    return retVal;
};
const de_LendingDetection = (output, context) => {
    return take(output, {
        Confidence: __limitedParseFloat32,
        Geometry: (_) => de_Geometry(_, context),
        SelectionStatus: __expectString,
        Text: __expectString,
    });
};
const de_LendingDetectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LendingDetection(entry, context);
    });
    return retVal;
};
const de_LendingDocument = (output, context) => {
    return take(output, {
        LendingFields: (_) => de_LendingFieldList(_, context),
        SignatureDetections: (_) => de_SignatureDetectionList(_, context),
    });
};
const de_LendingField = (output, context) => {
    return take(output, {
        KeyDetection: (_) => de_LendingDetection(_, context),
        Type: __expectString,
        ValueDetections: (_) => de_LendingDetectionList(_, context),
    });
};
const de_LendingFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LendingField(entry, context);
    });
    return retVal;
};
const de_LendingResult = (output, context) => {
    return take(output, {
        Extractions: (_) => de_ExtractionList(_, context),
        Page: __expectInt32,
        PageClassification: (_) => de_PageClassification(_, context),
    });
};
const de_LendingResultList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LendingResult(entry, context);
    });
    return retVal;
};
const de_LineItemFields = (output, context) => {
    return take(output, {
        LineItemExpenseFields: (_) => de_ExpenseFieldList(_, context),
    });
};
const de_LineItemGroup = (output, context) => {
    return take(output, {
        LineItemGroupIndex: __expectInt32,
        LineItems: (_) => de_LineItemList(_, context),
    });
};
const de_LineItemGroupList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LineItemGroup(entry, context);
    });
    return retVal;
};
const de_LineItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LineItemFields(entry, context);
    });
    return retVal;
};
const de_ListAdaptersResponse = (output, context) => {
    return take(output, {
        Adapters: (_) => de_AdapterList(_, context),
        NextToken: __expectString,
    });
};
const de_ListAdapterVersionsResponse = (output, context) => {
    return take(output, {
        AdapterVersions: (_) => de_AdapterVersionList(_, context),
        NextToken: __expectString,
    });
};
const de_PageClassification = (output, context) => {
    return take(output, {
        PageNumber: (_) => de_PredictionList(_, context),
        PageType: (_) => de_PredictionList(_, context),
    });
};
const de_Point = (output, context) => {
    return take(output, {
        X: __limitedParseFloat32,
        Y: __limitedParseFloat32,
    });
};
const de_Polygon = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Point(entry, context);
    });
    return retVal;
};
const de_Prediction = (output, context) => {
    return take(output, {
        Confidence: __limitedParseFloat32,
        Value: __expectString,
    });
};
const de_PredictionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Prediction(entry, context);
    });
    return retVal;
};
const de_SignatureDetection = (output, context) => {
    return take(output, {
        Confidence: __limitedParseFloat32,
        Geometry: (_) => de_Geometry(_, context),
    });
};
const de_SignatureDetectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SignatureDetection(entry, context);
    });
    return retVal;
};
const de_UpdateAdapterResponse = (output, context) => {
    return take(output, {
        AdapterId: __expectString,
        AdapterName: __expectString,
        AutoUpdate: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        FeatureTypes: _json,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `Textract.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
