{"version":3,"file":"virtual.mjs","names":["useDisplay","useResizeObserver","computed","nextTick","onScopeDispose","ref","shallowRef","watch","watchEffect","clamp","createRange","debounce","IN_BROWSER","propsFactory","UP","DOWN","BUFFER_PX","makeVirtualProps","itemHeight","type","Number","String","default","height","useVirtual","props","items","display","value","parseFloat","first","last","Math","ceil","parseInt","paddingTop","paddingBottom","containerRef","markerRef","markerOffset","resizeRef","contentRect","viewportHeight","document","documentElement","hasInitialRender","sizeMap","Map","sizes","Array","from","length","offsets","updateTime","targetScrollIndex","getSize","index","updateOffsets","start","performance","now","i","max","unwatch","v","offsetTop","immediate","calculateVisibleItems","window","requestAnimationFrame","scrollToIndex","val","oldVal","clear","handleItemResize","prevHeight","prevMinHeight","min","set","calculateOffset","calculateIndex","scrollTop","binaryClosest","lastScrollTop","scrollVelocity","lastScrollTime","handleScroll","scrollTime","scrollDeltaT","sign","handleScrollend","raf","cancelAnimationFrame","_calculateVisibleItems","direction","startPx","endPx","end","topOverflow","bottomOverflow","bufferOverflow","offset","computedItems","slice","map","item","raw","forEach","indexOf","delete","arr","high","low","mid","target"],"sources":["../../src/composables/virtual.ts"],"sourcesContent":["// Composables\nimport { useDisplay } from '@/composables/display'\nimport { useResizeObserver } from '@/composables/resizeObserver'\n\n// Utilities\nimport { computed, nextTick, onScopeDispose, ref, shallowRef, watch, watchEffect } from 'vue'\nimport {\n  clamp,\n  createRange,\n  debounce,\n  IN_BROWSER,\n  propsFactory,\n} from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\nconst UP = -1\nconst DOWN = 1\n\n/** Determines how large each batch of items should be */\nconst BUFFER_PX = 100\n\ntype VirtualProps = {\n  itemHeight?: number | string\n  height?: number | string\n}\n\nexport const makeVirtualProps = propsFactory({\n  itemHeight: {\n    type: [Number, String],\n    default: null,\n  },\n  height: [Number, String],\n}, 'virtual')\n\nexport function useVirtual <T> (props: VirtualProps, items: Ref<readonly T[]>) {\n  const display = useDisplay()\n\n  const itemHeight = shallowRef(0)\n  watchEffect(() => {\n    itemHeight.value = parseFloat(props.itemHeight || 0)\n  })\n\n  const first = shallowRef(0)\n  const last = shallowRef(Math.ceil(\n    // Assume 16px items filling the entire screen height if\n    // not provided. This is probably incorrect but it minimises\n    // the chance of ending up with empty space at the bottom.\n    // The default value is set here to avoid poisoning getSize()\n    (parseInt(props.height!) || display.height.value) / (itemHeight.value || 16)\n  ) || 1)\n  const paddingTop = shallowRef(0)\n  const paddingBottom = shallowRef(0)\n\n  /** The scrollable element */\n  const containerRef = ref<HTMLElement>()\n  /** An element marking the top of the scrollable area,\n   * used to add an offset if there's padding or other elements above the virtual list */\n  const markerRef = ref<HTMLElement>()\n  /** markerRef's offsetTop, lazily evaluated */\n  let markerOffset = 0\n\n  const { resizeRef, contentRect } = useResizeObserver()\n  watchEffect(() => {\n    resizeRef.value = containerRef.value\n  })\n  const viewportHeight = computed(() => {\n    return containerRef.value === document.documentElement\n      ? display.height.value\n      : contentRect.value?.height || parseInt(props.height!) || 0\n  })\n  /** All static elements have been rendered and we have an assumed item height */\n  const hasInitialRender = computed(() => {\n    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value)\n  })\n\n  const sizeMap = new Map<any, number>()\n  let sizes = Array.from<number | null>({ length: items.value.length })\n  const offsets = Array.from<number>({ length: items.value.length })\n  const updateTime = shallowRef(0)\n  let targetScrollIndex = -1\n\n  function getSize (index: number) {\n    return sizes[index] || itemHeight.value\n  }\n\n  const updateOffsets = debounce(() => {\n    const start = performance.now()\n    offsets[0] = 0\n    const length = items.value.length\n    for (let i = 1; i <= length - 1; i++) {\n      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1)\n    }\n    updateTime.value = Math.max(updateTime.value, performance.now() - start)\n  }, updateTime)\n\n  const unwatch = watch(hasInitialRender, v => {\n    if (!v) return\n    // First render is complete, update offsets and visible\n    // items in case our assumed item height was incorrect\n\n    unwatch()\n    markerOffset = markerRef.value!.offsetTop\n    updateOffsets.immediate()\n    calculateVisibleItems()\n\n    if (!~targetScrollIndex) return\n\n    nextTick(() => {\n      IN_BROWSER && window.requestAnimationFrame(() => {\n        scrollToIndex(targetScrollIndex)\n        targetScrollIndex = -1\n      })\n    })\n  })\n  watch(viewportHeight, (val, oldVal) => {\n    oldVal && calculateVisibleItems()\n  })\n\n  onScopeDispose(() => {\n    updateOffsets.clear()\n  })\n\n  function handleItemResize (index: number, height: number) {\n    const prevHeight = sizes[index]\n    const prevMinHeight = itemHeight.value\n\n    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height\n\n    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {\n      sizes[index] = height\n      sizeMap.set(items.value[index], height)\n      updateOffsets()\n    }\n  }\n\n  function calculateOffset (index: number) {\n    index = clamp(index, 0, items.value.length - 1)\n    return offsets[index] || 0\n  }\n\n  function calculateIndex (scrollTop: number) {\n    return binaryClosest(offsets, scrollTop)\n  }\n\n  let lastScrollTop = 0\n  let scrollVelocity = 0\n  let lastScrollTime = 0\n  function handleScroll () {\n    if (!containerRef.value || !markerRef.value) return\n\n    const scrollTop = containerRef.value.scrollTop\n    const scrollTime = performance.now()\n    const scrollDeltaT = scrollTime - lastScrollTime\n\n    if (scrollDeltaT > 500) {\n      scrollVelocity = Math.sign(scrollTop - lastScrollTop)\n\n      // Not super important, only update at the\n      // start of a scroll sequence to avoid reflows\n      markerOffset = markerRef.value.offsetTop\n    } else {\n      scrollVelocity = scrollTop - lastScrollTop\n    }\n\n    lastScrollTop = scrollTop\n    lastScrollTime = scrollTime\n\n    calculateVisibleItems()\n  }\n  function handleScrollend () {\n    if (!containerRef.value || !markerRef.value) return\n\n    scrollVelocity = 0\n    lastScrollTime = 0\n\n    calculateVisibleItems()\n  }\n\n  let raf = -1\n  function calculateVisibleItems () {\n    cancelAnimationFrame(raf)\n    raf = requestAnimationFrame(_calculateVisibleItems)\n  }\n  function _calculateVisibleItems () {\n    if (!containerRef.value || !viewportHeight.value) return\n    const scrollTop = lastScrollTop - markerOffset\n    const direction = Math.sign(scrollVelocity)\n\n    const startPx = Math.max(0, scrollTop - BUFFER_PX)\n    const start = clamp(calculateIndex(startPx), 0, items.value.length)\n\n    const endPx = scrollTop + viewportHeight.value + BUFFER_PX\n    const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length)\n\n    if (\n      // Only update the side we're scrolling towards,\n      // the other side will be updated incidentally\n      (direction !== UP || start < first.value) &&\n      (direction !== DOWN || end > last.value)\n    ) {\n      const topOverflow = calculateOffset(first.value) - calculateOffset(start)\n      const bottomOverflow = calculateOffset(end) - calculateOffset(last.value)\n      const bufferOverflow = Math.max(topOverflow, bottomOverflow)\n\n      if (bufferOverflow > BUFFER_PX) {\n        first.value = start\n        last.value = end\n      } else {\n        // Only update the side that's reached its limit if there's still buffer left\n        if (start <= 0) first.value = start\n        if (end >= items.value.length) last.value = end\n      }\n    }\n\n    paddingTop.value = calculateOffset(first.value)\n    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value)\n  }\n\n  function scrollToIndex (index: number) {\n    const offset = calculateOffset(index)\n    if (!containerRef.value || (index && !offset)) {\n      targetScrollIndex = index\n    } else {\n      containerRef.value.scrollTop = offset\n    }\n  }\n\n  const computedItems = computed(() => {\n    return items.value.slice(first.value, last.value).map((item, index) => ({\n      raw: item,\n      index: index + first.value,\n    }))\n  })\n\n  watch(() => items.value.length, () => {\n    sizes = createRange(items.value.length).map(() => itemHeight.value)\n    sizeMap.forEach((height, item) => {\n      const index = items.value.indexOf(item)\n      if (index === -1) {\n        sizeMap.delete(item)\n      } else {\n        sizes[index] = height\n      }\n    })\n    calculateVisibleItems()\n  })\n\n  return {\n    containerRef,\n    markerRef,\n    computedItems,\n    paddingTop,\n    paddingBottom,\n    scrollToIndex,\n    handleScroll,\n    handleScrollend,\n    handleItemResize,\n  }\n}\n\n// https://gist.github.com/robertleeplummerjr/1cc657191d34ecd0a324\nfunction binaryClosest (arr: ArrayLike<number>, val: number) {\n  let high = arr.length - 1\n  let low = 0\n  let mid = 0\n  let item = null\n  let target = -1\n\n  if (arr[high]! < val) {\n    return high\n  }\n\n  while (low <= high) {\n    mid = (low + high) >> 1\n    item = arr[mid]!\n\n    if (item > val) {\n      high = mid - 1\n    } else if (item < val) {\n      target = mid\n      low = mid + 1\n    } else if (item === val) {\n      return mid\n    } else {\n      return low\n    }\n  }\n\n  return target\n}\n"],"mappings":"AAAA;AAAA,SACSA,UAAU;AAAA,SACVC,iBAAiB,gCAE1B;AACA,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,GAAG,EAAEC,UAAU,EAAEC,KAAK,EAAEC,WAAW,QAAQ,KAAK;AAAA,SAE3FC,KAAK,EACLC,WAAW,EACXC,QAAQ,EACRC,UAAU,EACVC,YAAY,6BAGd;AAGA,MAAMC,EAAE,GAAG,CAAC,CAAC;AACb,MAAMC,IAAI,GAAG,CAAC;;AAEd;AACA,MAAMC,SAAS,GAAG,GAAG;AAOrB,OAAO,MAAMC,gBAAgB,GAAGJ,YAAY,CAAC;EAC3CK,UAAU,EAAE;IACVC,IAAI,EAAE,CAACC,MAAM,EAAEC,MAAM,CAAC;IACtBC,OAAO,EAAE;EACX,CAAC;EACDC,MAAM,EAAE,CAACH,MAAM,EAAEC,MAAM;AACzB,CAAC,EAAE,SAAS,CAAC;AAEb,OAAO,SAASG,UAAUA,CAAMC,KAAmB,EAAEC,KAAwB,EAAE;EAC7E,MAAMC,OAAO,GAAG3B,UAAU,EAAE;EAE5B,MAAMkB,UAAU,GAAGZ,UAAU,CAAC,CAAC,CAAC;EAChCE,WAAW,CAAC,MAAM;IAChBU,UAAU,CAACU,KAAK,GAAGC,UAAU,CAACJ,KAAK,CAACP,UAAU,IAAI,CAAC,CAAC;EACtD,CAAC,CAAC;EAEF,MAAMY,KAAK,GAAGxB,UAAU,CAAC,CAAC,CAAC;EAC3B,MAAMyB,IAAI,GAAGzB,UAAU,CAAC0B,IAAI,CAACC,IAAI;EAC/B;EACA;EACA;EACA;EACA,CAACC,QAAQ,CAACT,KAAK,CAACF,MAAM,CAAE,IAAII,OAAO,CAACJ,MAAM,CAACK,KAAK,KAAKV,UAAU,CAACU,KAAK,IAAI,EAAE,CAAC,CAC7E,IAAI,CAAC,CAAC;EACP,MAAMO,UAAU,GAAG7B,UAAU,CAAC,CAAC,CAAC;EAChC,MAAM8B,aAAa,GAAG9B,UAAU,CAAC,CAAC,CAAC;;EAEnC;EACA,MAAM+B,YAAY,GAAGhC,GAAG,EAAe;EACvC;AACF;EACE,MAAMiC,SAAS,GAAGjC,GAAG,EAAe;EACpC;EACA,IAAIkC,YAAY,GAAG,CAAC;EAEpB,MAAM;IAAEC,SAAS;IAAEC;EAAY,CAAC,GAAGxC,iBAAiB,EAAE;EACtDO,WAAW,CAAC,MAAM;IAChBgC,SAAS,CAACZ,KAAK,GAAGS,YAAY,CAACT,KAAK;EACtC,CAAC,CAAC;EACF,MAAMc,cAAc,GAAGxC,QAAQ,CAAC,MAAM;IACpC,OAAOmC,YAAY,CAACT,KAAK,KAAKe,QAAQ,CAACC,eAAe,GAClDjB,OAAO,CAACJ,MAAM,CAACK,KAAK,GACpBa,WAAW,CAACb,KAAK,EAAEL,MAAM,IAAIW,QAAQ,CAACT,KAAK,CAACF,MAAM,CAAE,IAAI,CAAC;EAC/D,CAAC,CAAC;EACF;EACA,MAAMsB,gBAAgB,GAAG3C,QAAQ,CAAC,MAAM;IACtC,OAAO,CAAC,EAAEmC,YAAY,CAACT,KAAK,IAAIU,SAAS,CAACV,KAAK,IAAIc,cAAc,CAACd,KAAK,IAAIV,UAAU,CAACU,KAAK,CAAC;EAC9F,CAAC,CAAC;EAEF,MAAMkB,OAAO,GAAG,IAAIC,GAAG,EAAe;EACtC,IAAIC,KAAK,GAAGC,KAAK,CAACC,IAAI,CAAgB;IAAEC,MAAM,EAAEzB,KAAK,CAACE,KAAK,CAACuB;EAAO,CAAC,CAAC;EACrE,MAAMC,OAAO,GAAGH,KAAK,CAACC,IAAI,CAAS;IAAEC,MAAM,EAAEzB,KAAK,CAACE,KAAK,CAACuB;EAAO,CAAC,CAAC;EAClE,MAAME,UAAU,GAAG/C,UAAU,CAAC,CAAC,CAAC;EAChC,IAAIgD,iBAAiB,GAAG,CAAC,CAAC;EAE1B,SAASC,OAAOA,CAAEC,KAAa,EAAE;IAC/B,OAAOR,KAAK,CAACQ,KAAK,CAAC,IAAItC,UAAU,CAACU,KAAK;EACzC;EAEA,MAAM6B,aAAa,GAAG9C,QAAQ,CAAC,MAAM;IACnC,MAAM+C,KAAK,GAAGC,WAAW,CAACC,GAAG,EAAE;IAC/BR,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC;IACd,MAAMD,MAAM,GAAGzB,KAAK,CAACE,KAAK,CAACuB,MAAM;IACjC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIV,MAAM,GAAG,CAAC,EAAEU,CAAC,EAAE,EAAE;MACpCT,OAAO,CAACS,CAAC,CAAC,GAAG,CAACT,OAAO,CAACS,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAIN,OAAO,CAACM,CAAC,GAAG,CAAC,CAAC;IACrD;IACAR,UAAU,CAACzB,KAAK,GAAGI,IAAI,CAAC8B,GAAG,CAACT,UAAU,CAACzB,KAAK,EAAE+B,WAAW,CAACC,GAAG,EAAE,GAAGF,KAAK,CAAC;EAC1E,CAAC,EAAEL,UAAU,CAAC;EAEd,MAAMU,OAAO,GAAGxD,KAAK,CAACsC,gBAAgB,EAAEmB,CAAC,IAAI;IAC3C,IAAI,CAACA,CAAC,EAAE;IACR;IACA;;IAEAD,OAAO,EAAE;IACTxB,YAAY,GAAGD,SAAS,CAACV,KAAK,CAAEqC,SAAS;IACzCR,aAAa,CAACS,SAAS,EAAE;IACzBC,qBAAqB,EAAE;IAEvB,IAAI,CAAC,CAACb,iBAAiB,EAAE;IAEzBnD,QAAQ,CAAC,MAAM;MACbS,UAAU,IAAIwD,MAAM,CAACC,qBAAqB,CAAC,MAAM;QAC/CC,aAAa,CAAChB,iBAAiB,CAAC;QAChCA,iBAAiB,GAAG,CAAC,CAAC;MACxB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;EACF/C,KAAK,CAACmC,cAAc,EAAE,CAAC6B,GAAG,EAAEC,MAAM,KAAK;IACrCA,MAAM,IAAIL,qBAAqB,EAAE;EACnC,CAAC,CAAC;EAEF/D,cAAc,CAAC,MAAM;IACnBqD,aAAa,CAACgB,KAAK,EAAE;EACvB,CAAC,CAAC;EAEF,SAASC,gBAAgBA,CAAElB,KAAa,EAAEjC,MAAc,EAAE;IACxD,MAAMoD,UAAU,GAAG3B,KAAK,CAACQ,KAAK,CAAC;IAC/B,MAAMoB,aAAa,GAAG1D,UAAU,CAACU,KAAK;IAEtCV,UAAU,CAACU,KAAK,GAAGgD,aAAa,GAAG5C,IAAI,CAAC6C,GAAG,CAAC3D,UAAU,CAACU,KAAK,EAAEL,MAAM,CAAC,GAAGA,MAAM;IAE9E,IAAIoD,UAAU,KAAKpD,MAAM,IAAIqD,aAAa,KAAK1D,UAAU,CAACU,KAAK,EAAE;MAC/DoB,KAAK,CAACQ,KAAK,CAAC,GAAGjC,MAAM;MACrBuB,OAAO,CAACgC,GAAG,CAACpD,KAAK,CAACE,KAAK,CAAC4B,KAAK,CAAC,EAAEjC,MAAM,CAAC;MACvCkC,aAAa,EAAE;IACjB;EACF;EAEA,SAASsB,eAAeA,CAAEvB,KAAa,EAAE;IACvCA,KAAK,GAAG/C,KAAK,CAAC+C,KAAK,EAAE,CAAC,EAAE9B,KAAK,CAACE,KAAK,CAACuB,MAAM,GAAG,CAAC,CAAC;IAC/C,OAAOC,OAAO,CAACI,KAAK,CAAC,IAAI,CAAC;EAC5B;EAEA,SAASwB,cAAcA,CAAEC,SAAiB,EAAE;IAC1C,OAAOC,aAAa,CAAC9B,OAAO,EAAE6B,SAAS,CAAC;EAC1C;EAEA,IAAIE,aAAa,GAAG,CAAC;EACrB,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,cAAc,GAAG,CAAC;EACtB,SAASC,YAAYA,CAAA,EAAI;IACvB,IAAI,CAACjD,YAAY,CAACT,KAAK,IAAI,CAACU,SAAS,CAACV,KAAK,EAAE;IAE7C,MAAMqD,SAAS,GAAG5C,YAAY,CAACT,KAAK,CAACqD,SAAS;IAC9C,MAAMM,UAAU,GAAG5B,WAAW,CAACC,GAAG,EAAE;IACpC,MAAM4B,YAAY,GAAGD,UAAU,GAAGF,cAAc;IAEhD,IAAIG,YAAY,GAAG,GAAG,EAAE;MACtBJ,cAAc,GAAGpD,IAAI,CAACyD,IAAI,CAACR,SAAS,GAAGE,aAAa,CAAC;;MAErD;MACA;MACA5C,YAAY,GAAGD,SAAS,CAACV,KAAK,CAACqC,SAAS;IAC1C,CAAC,MAAM;MACLmB,cAAc,GAAGH,SAAS,GAAGE,aAAa;IAC5C;IAEAA,aAAa,GAAGF,SAAS;IACzBI,cAAc,GAAGE,UAAU;IAE3BpB,qBAAqB,EAAE;EACzB;EACA,SAASuB,eAAeA,CAAA,EAAI;IAC1B,IAAI,CAACrD,YAAY,CAACT,KAAK,IAAI,CAACU,SAAS,CAACV,KAAK,EAAE;IAE7CwD,cAAc,GAAG,CAAC;IAClBC,cAAc,GAAG,CAAC;IAElBlB,qBAAqB,EAAE;EACzB;EAEA,IAAIwB,GAAG,GAAG,CAAC,CAAC;EACZ,SAASxB,qBAAqBA,CAAA,EAAI;IAChCyB,oBAAoB,CAACD,GAAG,CAAC;IACzBA,GAAG,GAAGtB,qBAAqB,CAACwB,sBAAsB,CAAC;EACrD;EACA,SAASA,sBAAsBA,CAAA,EAAI;IACjC,IAAI,CAACxD,YAAY,CAACT,KAAK,IAAI,CAACc,cAAc,CAACd,KAAK,EAAE;IAClD,MAAMqD,SAAS,GAAGE,aAAa,GAAG5C,YAAY;IAC9C,MAAMuD,SAAS,GAAG9D,IAAI,CAACyD,IAAI,CAACL,cAAc,CAAC;IAE3C,MAAMW,OAAO,GAAG/D,IAAI,CAAC8B,GAAG,CAAC,CAAC,EAAEmB,SAAS,GAAGjE,SAAS,CAAC;IAClD,MAAM0C,KAAK,GAAGjD,KAAK,CAACuE,cAAc,CAACe,OAAO,CAAC,EAAE,CAAC,EAAErE,KAAK,CAACE,KAAK,CAACuB,MAAM,CAAC;IAEnE,MAAM6C,KAAK,GAAGf,SAAS,GAAGvC,cAAc,CAACd,KAAK,GAAGZ,SAAS;IAC1D,MAAMiF,GAAG,GAAGxF,KAAK,CAACuE,cAAc,CAACgB,KAAK,CAAC,GAAG,CAAC,EAAEtC,KAAK,GAAG,CAAC,EAAEhC,KAAK,CAACE,KAAK,CAACuB,MAAM,CAAC;IAE3E;IACE;IACA;IACA,CAAC2C,SAAS,KAAKhF,EAAE,IAAI4C,KAAK,GAAG5B,KAAK,CAACF,KAAK,MACvCkE,SAAS,KAAK/E,IAAI,IAAIkF,GAAG,GAAGlE,IAAI,CAACH,KAAK,CAAC,EACxC;MACA,MAAMsE,WAAW,GAAGnB,eAAe,CAACjD,KAAK,CAACF,KAAK,CAAC,GAAGmD,eAAe,CAACrB,KAAK,CAAC;MACzE,MAAMyC,cAAc,GAAGpB,eAAe,CAACkB,GAAG,CAAC,GAAGlB,eAAe,CAAChD,IAAI,CAACH,KAAK,CAAC;MACzE,MAAMwE,cAAc,GAAGpE,IAAI,CAAC8B,GAAG,CAACoC,WAAW,EAAEC,cAAc,CAAC;MAE5D,IAAIC,cAAc,GAAGpF,SAAS,EAAE;QAC9Bc,KAAK,CAACF,KAAK,GAAG8B,KAAK;QACnB3B,IAAI,CAACH,KAAK,GAAGqE,GAAG;MAClB,CAAC,MAAM;QACL;QACA,IAAIvC,KAAK,IAAI,CAAC,EAAE5B,KAAK,CAACF,KAAK,GAAG8B,KAAK;QACnC,IAAIuC,GAAG,IAAIvE,KAAK,CAACE,KAAK,CAACuB,MAAM,EAAEpB,IAAI,CAACH,KAAK,GAAGqE,GAAG;MACjD;IACF;IAEA9D,UAAU,CAACP,KAAK,GAAGmD,eAAe,CAACjD,KAAK,CAACF,KAAK,CAAC;IAC/CQ,aAAa,CAACR,KAAK,GAAGmD,eAAe,CAACrD,KAAK,CAACE,KAAK,CAACuB,MAAM,CAAC,GAAG4B,eAAe,CAAChD,IAAI,CAACH,KAAK,CAAC;EACzF;EAEA,SAAS0C,aAAaA,CAAEd,KAAa,EAAE;IACrC,MAAM6C,MAAM,GAAGtB,eAAe,CAACvB,KAAK,CAAC;IACrC,IAAI,CAACnB,YAAY,CAACT,KAAK,IAAK4B,KAAK,IAAI,CAAC6C,MAAO,EAAE;MAC7C/C,iBAAiB,GAAGE,KAAK;IAC3B,CAAC,MAAM;MACLnB,YAAY,CAACT,KAAK,CAACqD,SAAS,GAAGoB,MAAM;IACvC;EACF;EAEA,MAAMC,aAAa,GAAGpG,QAAQ,CAAC,MAAM;IACnC,OAAOwB,KAAK,CAACE,KAAK,CAAC2E,KAAK,CAACzE,KAAK,CAACF,KAAK,EAAEG,IAAI,CAACH,KAAK,CAAC,CAAC4E,GAAG,CAAC,CAACC,IAAI,EAAEjD,KAAK,MAAM;MACtEkD,GAAG,EAAED,IAAI;MACTjD,KAAK,EAAEA,KAAK,GAAG1B,KAAK,CAACF;IACvB,CAAC,CAAC,CAAC;EACL,CAAC,CAAC;EAEFrB,KAAK,CAAC,MAAMmB,KAAK,CAACE,KAAK,CAACuB,MAAM,EAAE,MAAM;IACpCH,KAAK,GAAGtC,WAAW,CAACgB,KAAK,CAACE,KAAK,CAACuB,MAAM,CAAC,CAACqD,GAAG,CAAC,MAAMtF,UAAU,CAACU,KAAK,CAAC;IACnEkB,OAAO,CAAC6D,OAAO,CAAC,CAACpF,MAAM,EAAEkF,IAAI,KAAK;MAChC,MAAMjD,KAAK,GAAG9B,KAAK,CAACE,KAAK,CAACgF,OAAO,CAACH,IAAI,CAAC;MACvC,IAAIjD,KAAK,KAAK,CAAC,CAAC,EAAE;QAChBV,OAAO,CAAC+D,MAAM,CAACJ,IAAI,CAAC;MACtB,CAAC,MAAM;QACLzD,KAAK,CAACQ,KAAK,CAAC,GAAGjC,MAAM;MACvB;IACF,CAAC,CAAC;IACF4C,qBAAqB,EAAE;EACzB,CAAC,CAAC;EAEF,OAAO;IACL9B,YAAY;IACZC,SAAS;IACTgE,aAAa;IACbnE,UAAU;IACVC,aAAa;IACbkC,aAAa;IACbgB,YAAY;IACZI,eAAe;IACfhB;EACF,CAAC;AACH;;AAEA;AACA,SAASQ,aAAaA,CAAE4B,GAAsB,EAAEvC,GAAW,EAAE;EAC3D,IAAIwC,IAAI,GAAGD,GAAG,CAAC3D,MAAM,GAAG,CAAC;EACzB,IAAI6D,GAAG,GAAG,CAAC;EACX,IAAIC,GAAG,GAAG,CAAC;EACX,IAAIR,IAAI,GAAG,IAAI;EACf,IAAIS,MAAM,GAAG,CAAC,CAAC;EAEf,IAAIJ,GAAG,CAACC,IAAI,CAAC,GAAIxC,GAAG,EAAE;IACpB,OAAOwC,IAAI;EACb;EAEA,OAAOC,GAAG,IAAID,IAAI,EAAE;IAClBE,GAAG,GAAID,GAAG,GAAGD,IAAI,IAAK,CAAC;IACvBN,IAAI,GAAGK,GAAG,CAACG,GAAG,CAAE;IAEhB,IAAIR,IAAI,GAAGlC,GAAG,EAAE;MACdwC,IAAI,GAAGE,GAAG,GAAG,CAAC;IAChB,CAAC,MAAM,IAAIR,IAAI,GAAGlC,GAAG,EAAE;MACrB2C,MAAM,GAAGD,GAAG;MACZD,GAAG,GAAGC,GAAG,GAAG,CAAC;IACf,CAAC,MAAM,IAAIR,IAAI,KAAKlC,GAAG,EAAE;MACvB,OAAO0C,GAAG;IACZ,CAAC,MAAM;MACL,OAAOD,GAAG;IACZ;EACF;EAEA,OAAOE,MAAM;AACf"}